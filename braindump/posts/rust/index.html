<!DOCTYPE html>
<html><title>rust</title>


<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="google-site-verification" content="bLmaFyyXugiCqSup-eIIIx0B4CngtdF_svyMMKQbS5E" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=10, minimum-scale=0.5, user-scalable=yes">
<meta name="apple-mobile-web-app-capable" content="yes" />
<script src="https://hypothes.is/embed.js" async></script>


<link rel="stylesheet" href="/braindump/css/main.min.56b43bcbc759a196f9dd525bee62bdec45a29ba95902bbab74a4f7ad2ea3e8cb.css"/>

<link rel="stylesheet" href="/braindump/css/links.min.4bf1990b213fb76d2a66153dc6ef9a57d49f536c6baf6e7f19a7948470a38141.css"/>

<link rel="stylesheet" href="/braindump/css/konubinix.min.cf2d0f36945178c647979ee68f1830892e06aa3d481d8913728b5c7462b97f6e.css"/>

<link rel="stylesheet" href="/ipfs/QmQFVQS89fv1XUNFcjwCKDePzckuT9kpuAVNYUwNdEfYcv/css/all.css"/>
<link rel="shortcut icon" href="/ipfs/QmVFwYV7YRZLKU3ybN1hW4jqfyZGPLKJwd8toN2wHz5UAD?a.png" type="image/x-icon" />

<body><header>
  <div>
	<a href="/braindump//"><h5 class="site-title">Konubinix&#39; opinionated web of thoughts</h5></a>
  </div>
  <span>
	<a href="/blog/"><i class="icon fas fa-blog"></i></a>
	<a href="/braindump/posts/"><i class="icon fas fa-brain"></i></a>
    <a href="mailto:konubinixweb@gmail.com"><i class="icon fas fa-envelope-square"></i></a>
    <a href="https://github.com/konubinix"><i class="icon fab fa-github-square"></i></a>
    <a href="https://linkedin.com/in/samuel-loury-61259040"><i class="icon fab fa-linkedin"></i></a>
	<a href="/braindump/graph.html"><i class="icon fas fa-project-diagram"></i></a>
	<a href="/braindump/index.xml"><i class="icon fas fa-rss-square"></i></a>
	<a href="/braindump/tags/"><i class="icon fa fa-tag"></i></a>
	<a href="/braindump/braindump_search"><i class="icon fa fa-search"></i></a>
  </span>
</header>

<div class="grid-container">
  <div class="grid">
    <div class="page" data-level="1">
      <div class="content">
		<p class="lead">
        <h1>Rust</h1>
		<span class="badge badge-pill badge-warning"><a href="/braindump/tags/fleeting/">Fleeting</a></span></p>
        <h2 id="850d107f-e77c-4202-b912-803aacf071c9">cargo (package manager)</h2>
<h3 id="b27f443e-a4a4-4736-ab6c-6f236a2ce804"><a href="/braindump/posts/semantic_versioning_2_0_0/">semver</a> in <a href="#850d107f-e77c-4202-b912-803aacf071c9">rust cargo</a></h3>
<blockquote>
<p>specifier 0.8.5 is actually
shorthand for ^0.8.5, which means any version that is at least 0.8.5 but
below 0.9.0.</p>
</blockquote>
<blockquote>
<p>&mdash; <a href="https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html">https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>When you build your project in the future, Cargo will see
that the Cargo.lock file exists and will use the versions specified there
rather than doing all the work of figuring out versions again. This lets you
have a reproducible build automatically.</p>
<p>&mdash; <a href="https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html">https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>When you do want to update a crate, Cargo provides the command update,
which will ignore the Cargo.lock file and figure out all the latest versions
that fit your specifications in Cargo.toml.</p>
<p>&mdash; <a href="https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html">https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>Cargo will only look
for versions greater than 0.8.5 and less than 0.9.0</p>
<p>&mdash; <a href="https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html">https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>To use rand version 0.9.0 or any version in the 0.9.x
series, you’d have to update the Cargo.toml file to look like this instead:
[dependencies]
rand = &ldquo;0.9.0&rdquo;</p>
<p>&mdash; <a href="https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html">https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html</a></p>
</blockquote>
<h3 id="3bd60b7e-fe19-4547-a9ff-3bd18016719d">documentation generation</h3>
<blockquote>
<p>it. Another neat feature of Cargo is that running the cargo doc &ndash;open command will build documentation provided by all your dependencies
locally and open it in your browse</p>
<p>&mdash; <a href="https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html">https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html</a></p>
</blockquote>
<h2 id="784e3930-6a70-4208-9bcc-4c78eaebe4ab">memory handling</h2>
<ul>
<li>
<p>Référence externe : <a href="https://doc.rust-lang.org/book/ch15-02-deref.html">https://doc.rust-lang.org/book/ch15-02-deref.html</a></p>
</li>
<li>
<p>Référence externe : <a href="https://doc.rust-lang.org/rust-by-example/std/hash/alt_key_types.html">https://doc.rust-lang.org/rust-by-example/std/hash/alt_key_types.html</a></p>
</li>
<li>
<p>Référence externe : <a href="https://doc.rust-lang.org/rust-by-example/std/str.html">https://doc.rust-lang.org/rust-by-example/std/str.html</a></p>
</li>
<li>
<p>Référence externe : <a href="https://doc.rust-lang.org/rust-by-example/trait/drop.html">https://doc.rust-lang.org/rust-by-example/trait/drop.html</a></p>
</li>
<li>
<p>Référence externe : <a href="https://doc.rust-lang.org/book/appendix-03-derivable-traits.html">https://doc.rust-lang.org/book/appendix-03-derivable-traits.html</a></p>
</li>
<li>
<p>Référence externe : <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html">https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html</a></p>
<blockquote>
<p>Deref coercion is a convenience that Rust performs on arguments to functions
and methods</p>
<p>&mdash; <a href="https://doc.rust-lang.org/book/ch15-02-deref.html">https://doc.rust-lang.org/book/ch15-02-deref.html</a></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>Deref coercion works only on types that implement the Deref
trait.</p>
<p>&mdash; <a href="https://doc.rust-lang.org/book/ch15-02-deref.html">https://doc.rust-lang.org/book/ch15-02-deref.html</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>Note that f32 and f64 do not implement Hash,
likely because floating-point precision errors
would make using them as hashmap keys horribly error-prone</p>
<p>&mdash; <a href="https://doc.rust-lang.org/rust-by-example/std/hash/alt_key_types.html">https://doc.rust-lang.org/rust-by-example/std/hash/alt_key_types.html</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>A String is stored as a vector of bytes (Vec&lt;u8&gt;), but guaranteed to
always be a valid UTF-8 sequence. String is heap allocated, growable and not
null terminated</p>
<p>&mdash; <a href="https://doc.rust-lang.org/rust-by-example/std/str.html">https://doc.rust-lang.org/rust-by-example/std/str.html</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>&amp;str is a slice (&amp;[u8]) that always points to a valid UTF-8 sequence, and
can be used to view into a String, just like &amp;[T] is a view into Vec&lt;T&gt;.</p>
<p>&mdash; <a href="https://doc.rust-lang.org/rust-by-example/std/str.html">https://doc.rust-lang.org/rust-by-example/std/str.html</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>Box, Vec, String, File, and Process are some examples of types that
implement the Drop trait to free resources. The Drop trait can also be
manually implemented for any custom data type.</p>
<p>&mdash; <a href="https://doc.rust-lang.org/rust-by-example/trait/drop.html">https://doc.rust-lang.org/rust-by-example/trait/drop.html</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>When your code calls a function, the values passed into the function
(including, potentially, pointers to data on the heap) and the function’s
local variables get pushed onto the stack. When the function is over, those
values get popped off the stack.</p>
<p>&mdash; <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html">https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>We now have two variables, x
and y, and both equal 5. This is indeed what is happening, because integers
are simple values with a known, fixed size, and these two 5 values are pushed
onto the stack.</p>
<p>&mdash; <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html">https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>Rust has a special annotation called the Copy trait that we can place on
types like integers that are stored on the stack (we’ll talk more about traits
in Chapter 10). If a type implements the Copy trait, an older variable is
still usable after assignment. Rust won’t let us annotate a type with the
Copy trait if the type, or any of its parts, has implemented the Drop
trait. If the type needs something special to happen when the value goes out of
scope and we add the Copy annotation to that type, we’ll get a compile-time
error.</p>
<p>&mdash; <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html">https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>type that implements Copy must also implement Clone, because a type that
implements Copy has a trivial implementation of Clone that performs the same
task as Copy.</p>
<p>&mdash; <a href="https://doc.rust-lang.org/book/appendix-03-derivable-traits.html">https://doc.rust-lang.org/book/appendix-03-derivable-traits.html</a></p>
</blockquote>
<h2 id="556c75de-1cbc-4112-8603-b91de5c786de">dynamic typing</h2>
<ul>
<li>
<p>Référence externe : <a href="https://doc.rust-lang.org/rust-by-example/trait/ops.html">https://doc.rust-lang.org/rust-by-example/trait/ops.html</a></p>
</li>
<li>
<p>Référence externe : <a href="https://doc.rust-lang.org/rust-by-example/trait/dyn.html">https://doc.rust-lang.org/rust-by-example/trait/dyn.html</a></p>
</li>
<li>
<p>Référence externe : <a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html">https://doc.rust-lang.org/book/ch17-02-trait-objects.html</a></p>
<blockquote>
<p>operators are syntactic sugar for method calls. For example, the + operator in
a + b calls the add method (as in a.add(b)). This add method is part of the Add
trait. Hence, the + operator can be used by any implementor of the Add trait.</p>
<p>&mdash; <a href="https://doc.rust-lang.org/rust-by-example/trait/ops.html">https://doc.rust-lang.org/rust-by-example/trait/ops.html</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>Rust compiler needs to know how much space every function&rsquo;s return type
requires. This means all your functions have to return a concrete type. Unlike
other languages, if you have a trait like Animal, you can&rsquo;t write a function
that returns Animal, because its different implementations will need different
amounts of memory</p>
<p>&mdash; <a href="https://doc.rust-lang.org/rust-by-example/trait/dyn.html">https://doc.rust-lang.org/rust-by-example/trait/dyn.html</a></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>Instead of returning a trait object directly, our functions return a Box which
contains some Animal. A box is just a reference to some memory in the
heap. Because a reference has a statically-known size, and the compiler can
guarantee it points to a heap-allocated Animal, we can return a trait from our
function!</p>
<p>&mdash; <a href="https://doc.rust-lang.org/rust-by-example/trait/dyn.html">https://doc.rust-lang.org/rust-by-example/trait/dyn.html</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>trait object points to both an instance of a type implementing our specified
trait as well as a table used to look up trait methods on that type at
runtime. We create a trait object by specifying some sort of pointer, such as a
&amp; reference or a Box&lt;T&gt; smart pointer, then the dyn keyword, and then specifying
the relevant trait. (We’ll talk about the reason trait objects must use a
pointer in Chapter 19 in the section “Dynamically Sized Types and the Sized
Trait.”) We can use trait objects in place of a generic or concrete type.
Wherever we use a trait object, Rust’s type system will ensure at compile time
that any value used in that context will implement the trait object’s trait.
Consequently, we don’t need to know all the possible types at compile time.</p>
<p>&mdash; <a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html">https://doc.rust-lang.org/book/ch17-02-trait-objects.html</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>This concept—of being concerned only with the messages a value responds to
rather than the value’s concrete type—is similar to the concept of <a href="/braindump/posts/duck_typing/">duck typing</a>
in dynamically typed languages: if it walks like a duck and quacks like a duck,
then it must be a duck!</p>
<p>&mdash; <a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html">https://doc.rust-lang.org/book/ch17-02-trait-objects.html</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>advantage of using trait objects and Rust’s type system to write code
similar to code using duck typing is that we never have to check whether a
value implements a particular method at runtime or worry about getting errors
if a value doesn’t implement a method but we call it anyway. Rust won’t compile
our code if the values don’t implement the traits that the trait objects need.</p>
<p>&mdash; <a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html">https://doc.rust-lang.org/book/ch17-02-trait-objects.html</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>Trait Objects Perform Dynamic Dispatch
Recall in the “Performance of Code Using
Generics” section in
Chapter 10 our discussion on the monomorphization process performed by the
compiler when we use trait bounds on generics: the compiler generates
nongeneric implementations of functions and methods for each concrete type
that we use in place of a generic type parameter. The code that results from
monomorphization is doing static dispatch, which is when the compiler knows
what method you’re calling at compile time. This is opposed to dynamic
dispatch, which is when the compiler can’t tell at compile time which method
you’re calling. In dynamic dispatch cases, the compiler emits code that at
runtime will figure out which method to call</p>
<p>&mdash; <a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html">https://doc.rust-lang.org/book/ch17-02-trait-objects.html</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>When we use trait objects, Rust must use dynamic dispatch</p>
<p>&mdash; <a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html">https://doc.rust-lang.org/book/ch17-02-trait-objects.html</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>The compiler doesn’t
know all the types that might be used with the code that is using trait
objects, so it doesn’t know which method implemented on which type to call.
Instead, at runtime, Rust uses the pointers inside the trait object to know
which method to call. There is a runtime cost when this lookup happens that
doesn’t occur with static dispatch.</p>
<p>&mdash; <a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html">https://doc.rust-lang.org/book/ch17-02-trait-objects.html</a></p>
</blockquote>
<h2 id="ad5e3a45-e3f2-4e8f-b332-d0743bfdd10e">lifetime</h2>
<ul>
<li>
<p>Référence externe : <a href="https://doc.rust-lang.org/stable/rust-by-example/scope/lifetime/struct.html">https://doc.rust-lang.org/stable/rust-by-example/scope/lifetime/struct.html</a></p>
</li>
<li>
<p>Référence externe : <a href="https://doc.rust-lang.org/rust-by-example/scope/lifetime/lifetime_bounds.html">https://doc.rust-lang.org/rust-by-example/scope/lifetime/lifetime_bounds.html</a></p>
</li>
<li>
<p>Référence externe : <a href="https://doc.rust-lang.org/rust-by-example/scope/lifetime/fn.html">https://doc.rust-lang.org/rust-by-example/scope/lifetime/fn.html</a></p>
</li>
<li>
<p>Référence externe : <a href="https://doc.rust-lang.org/rust-by-example/scope/lifetime.html">https://doc.rust-lang.org/rust-by-example/scope/lifetime.html</a></p>
</li>
<li>
<p>Référence externe : <a href="https://doc.rust-lang.org/stable/book/ch10-03-lifetime-syntax.html">https://doc.rust-lang.org/stable/book/ch10-03-lifetime-syntax.html</a></p>
<blockquote>
<p>references here must outlive this structure</p>
<p>&mdash; <a href="https://doc.rust-lang.org/stable/rust-by-example/scope/lifetime/struct.html">https://doc.rust-lang.org/stable/rust-by-example/scope/lifetime/struct.html</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<ul>
<li>T: &lsquo;a: All references in T must outlive lifetime &lsquo;a.</li>
<li>T: Trait + &lsquo;a: Type T must implement trait Trait and all references</li>
</ul>
<p>in T must outlive &lsquo;a.</p>
<p>&mdash; <a href="https://doc.rust-lang.org/rust-by-example/scope/lifetime/lifetime_bounds.html">https://doc.rust-lang.org/rust-by-example/scope/lifetime/lifetime_bounds.html</a></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>function signatures with lifetimes have a few constraints:</p>
<p>any reference must have an annotated lifetime.
any reference being returned must have the same lifetime as an input or
be static.</p>
<p>&mdash; <a href="https://doc.rust-lang.org/rust-by-example/scope/lifetime/fn.html">https://doc.rust-lang.org/rust-by-example/scope/lifetime/fn.html</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>note that returning references without input is banned if it
would result in returning references to invalid data</p>
<p>&mdash; <a href="https://doc.rust-lang.org/rust-by-example/scope/lifetime/fn.html">https://doc.rust-lang.org/rust-by-example/scope/lifetime/fn.html</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>A lifetime is a construct the compiler (or more specifically, its borrow
checker) uses to ensure all borrows are valid. Specifically, a variable&rsquo;s
lifetime begins when it is created and ends when it is destroyed. While
lifetimes and scopes are often referred to together, they are not the same.</p>
<p>&mdash; <a href="https://doc.rust-lang.org/rust-by-example/scope/lifetime.html">https://doc.rust-lang.org/rust-by-example/scope/lifetime.html</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>Lifetime annotations don’t change how long any of the references live. Just
as functions can accept any type when the signature specifies a generic type
parameter, functions can accept references with any lifetime by specifying a
generic lifetime parameter. Lifetime annotations describe the relationships of
the lifetimes of multiple references to each other without affecting the
lifetimes.</p>
<p>&mdash; <a href="https://doc.rust-lang.org/stable/book/ch10-03-lifetime-syntax.html">https://doc.rust-lang.org/stable/book/ch10-03-lifetime-syntax.html</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>how generic lifetime parameters of multiple
references relate to each other</p>
<p>&mdash; <a href="https://doc.rust-lang.org/stable/book/ch10-03-lifetime-syntax.html">https://doc.rust-lang.org/stable/book/ch10-03-lifetime-syntax.html</a></p>
</blockquote>
<!--more-->
<h2 id="notes-pointant-ici">Notes pointant ici</h2>
<ul>
<li><a href="/braindump/posts/advice_for_computer_scientists/">advice for computer scientists</a></li>
<li><a href="/braindump/posts/apprendre_une_technologie_en_tant_qu_objectif_instrumental/">apprendre une technologie en tant qu&rsquo;objectif instrumental</a></li>
<li><a href="/braindump/posts/cargo_chef/">cargo-chef</a></li>
<li><a href="/braindump/posts/cli_with_rust/">cli with rust</a></li>
<li><a href="/braindump/posts/fortanix_enclave_development_platform/">fortanix enclave development platform</a></li>
<li><a href="/braindump/posts/handling_errors_and_panic_in_rust/">handling errors and panic in rust</a></li>
<li><a href="/braindump/posts/interior_mutability/">interior mutability</a></li>
<li><a href="/braindump/posts/iter_and_into_iter_in_rust/">iter and into_iter in rust?</a></li>
<li><a href="/braindump/posts/monadic_error_handling_in_python_write_better_python_code_part_7b_youtube/">Monadic Error Handling in Python ⚠ Write Better Python Code Part 7B - YouTube</a></li>
<li><a href="/braindump/posts/monomorphization/">monomorphization</a></li>
<li><a href="https://konubinix.eu/blog/posts/the_blog_of_konubinix/?title=my_tools#my-tools">My tools</a> (blog)</li>
<li><a href="/braindump/posts/rust_closures_and_move_semantic/">rust closures and move semantic</a></li>
<li><a href="/braindump/posts/rust_editions/">rust editions</a></li>
<li><a href="/braindump/posts/rust_macros/">rust macros</a></li>
<li><a href="/braindump/posts/rust_magical_box_as_smartpointer/">rust magical box as smartpointer</a></li>
<li><a href="/braindump/posts/rust_nightly/">rust nightly</a></li>
<li><a href="/braindump/posts/rust_to_machine_code/">rust to machine code</a></li>
<li><a href="/braindump/posts/rustup_rs_the_rust_toolchain_installer/">rustup.rs - The Rust toolchain installer</a></li>
<li><a href="/braindump/posts/strings_in_rust/">strings in rust</a></li>
<li><a href="/braindump/posts/tezedge/">tezedge</a></li>
<li><a href="/braindump/posts/trying_rust_in_webassembly/">trying rust in webassembly</a></li>
<li><a href="/braindump/posts/usagi_rust_memory_container_cs_rust_memory_container_cheat_sheet/">usagi/rust-memory-container-cs: Rust Memory Container Cheat-sheet</a></li>
<li><a href="/braindump/posts/wasm_in_rust/">wasm in rust</a></li>
<li><a href="/braindump/posts/why_precising_the_generic_in_the_impl_in_rust/">why precising the generic in the impl in rust</a></li>
</ul>
<h2 id="permalink"><a href="https://konubinix.eu/braindump/dab6dc52-40d8-4376-8b56-e6053c83f503?title=rust">Permalink</a></h2>
      </div>
	  <aside class="date"><time>Last updated: 05 Mar 2024</time></aside>
	  <aside class="date"><time>Published&nbsp;&nbsp;&nbsp;: 18 Jan 2021</time></aside>
    </div>
  </div>
</div>

<script src="/braindump/js/URI.js" type="text/javascript"></script>

<script src="/braindump/js/page.js" type="text/javascript"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>
