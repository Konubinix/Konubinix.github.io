<!DOCTYPE html>
<html><title>OAuth 2.0</title>


<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="google-site-verification" content="bLmaFyyXugiCqSup-eIIIx0B4CngtdF_svyMMKQbS5E" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=10, minimum-scale=0.5, user-scalable=yes">
<meta name="apple-mobile-web-app-capable" content="yes" />
<script src="https://hypothes.is/embed.js" async></script>


<link rel="stylesheet" href="/braindump/css/main.min.56b43bcbc759a196f9dd525bee62bdec45a29ba95902bbab74a4f7ad2ea3e8cb.css"/>

<link rel="stylesheet" href="/braindump/css/links.min.4bf1990b213fb76d2a66153dc6ef9a57d49f536c6baf6e7f19a7948470a38141.css"/>

<link rel="stylesheet" href="/braindump/css/konubinix.min.cf2d0f36945178c647979ee68f1830892e06aa3d481d8913728b5c7462b97f6e.css"/>

<link rel="stylesheet" href="/ipfs/QmQFVQS89fv1XUNFcjwCKDePzckuT9kpuAVNYUwNdEfYcv/css/all.css"/>
<link rel="shortcut icon" href="/ipfs/QmVFwYV7YRZLKU3ybN1hW4jqfyZGPLKJwd8toN2wHz5UAD?a.png" type="image/x-icon" />

<body><header>
  <div>
	<a href="/braindump//"><h5 class="site-title">Konubinix&#39; opinionated web of thoughts</h5></a>
  </div>
  <span>
	<a href="/blog/"><i class="icon fas fa-blog"></i></a>
	<a href="/braindump/posts/"><i class="icon fas fa-brain"></i></a>
    <a href="mailto:konubinixweb@gmail.com"><i class="icon fas fa-envelope-square"></i></a>
    <a href="https://github.com/konubinix"><i class="icon fab fa-github-square"></i></a>
    <a href="https://linkedin.com/in/samuel-loury-61259040"><i class="icon fab fa-linkedin"></i></a>
	<a href="/braindump/graph.html"><i class="icon fas fa-project-diagram"></i></a>
	<a href="/braindump/index.xml"><i class="icon fas fa-rss-square"></i></a>
	<a href="/braindump/tags/"><i class="icon fa fa-tag"></i></a>
	<a href="/braindump/braindump_search"><i class="icon fa fa-search"></i></a>
  </span>
</header>

<div class="grid-container">
  <div class="grid">
    <div class="page" data-level="1">
      <div class="content">
		<p class="lead">
        <h1>OAuth 2.0</h1>
		<span class="badge badge-pill badge-warning"><a href="/braindump/tags/fleeting/">Fleeting</a></span></p>
        <div class="ox-hugo-toc toc">
<div class="heading">Table des mati√®res</div>
<ul>
<li><a href="#02c86448-ca36-4995-b93e-fec4967b3b9c">third-party vs first-party</a></li>
<li><a href="#90cbca1f-13ff-4f8d-9077-18722d75ae55">scope</a></li>
<li><a href="#7b976efb-d964-4d48-acb7-1974de405bcc">what is not OAuth 2.0 is not useless or a bad idea</a></li>
<li><a href="#b0c592a9-32eb-468c-b342-962e6ab44d48">the purpose of OAuth 2.0 was to avoid that the client oauth 2.0 sees the resource owner&rsquo;s password</a></li>
<li><a href="#1d0956e3-43f6-44fb-9f18-a19c69980b1e">user consent screen</a></li>
<li><a href="#29bf253c-9d6a-4287-94a0-18403f092029">it starts with a oauth 2.0 client registering itself with a authorization server</a></li>
<li><a href="#964ef238-3cbc-44aa-8fda-83d04ae41052">user agent</a></li>
<li><a href="#134cb1c6-0fdb-420a-adae-c3e5e8f597f0">two modes of communication</a>
<ul>
<li><a href="#116966da-935d-4b55-8275-25316ca48534">an ambiguity</a>
<ul>
<li><a href="#e1507f32-33af-486a-b122-e38846bd470c">front channel is about UI and the back channel is about converting the outcome of the frontchannel to tokens</a></li>
</ul>
</li>
<li><a href="#9f31519d-b4cf-49c6-8209-ddb2458bcb91">back channel</a></li>
<li><a href="#29459edd-a5f0-407f-9457-54e30455bac7">front channel</a>
<ul>
<li><a href="#919d41f4-704d-4170-9eac-5d6ed74ce331">metaphor of the wall</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ffcfb38c-79eb-446e-a10c-e39c5b2e45fa">cross jwt confusion</a></li>
<li><a href="#1c5ce2b0-1b28-4f35-8978-3ba8acd027b0">5 types of grant -&gt; now only 2</a>
<ul>
<li><a href="#def201dd-26c7-44f9-8456-ad5d3c631731">authorization code grant</a>
<ul>
<li><a href="#63bc2c1a-054f-423d-9233-c4673892c57d">access token request</a></li>
<li><a href="#65dc3014-485c-499c-937b-33cf88330b2f">authorization code</a></li>
</ul>
</li>
<li><a href="#e0103c93-f693-4883-b331-b1ecb8ef88a0">password grant</a></li>
<li><a href="#e296ff6e-e206-4d1e-840e-1971682b45e2">implicit grant</a></li>
</ul>
</li>
<li><a href="#a86c2b04-58d7-48fc-947f-b199e5b9d3f0">What is an Access Token?</a></li>
<li><a href="#ead7dfac-e39a-4262-8066-a9e594d1b8a3">authorization server</a>
<ul>
<li><a href="#1e5b1c0a-9021-402a-9274-0151b47cb349">authorization request</a>
<ul>
<li><a href="#a37efbc7-01c6-4f37-96be-524bf9ea223b">Rich Authorization Requests</a></li>
<li><a href="#763e874e-ad40-489f-8a13-b1e47cf26d63">JWT-Secured Authorization Request</a></li>
<li><a href="#78f6fe2d-0be8-4706-9f15-03cc99923cde">Pushed Authorization Requests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#06528c1b-08f2-437a-86e3-890587ec0199">the resource owner needs to know the authorization server and trust it</a></li>
<li><a href="#72564685-ad13-4af1-8a9a-8230b967a36b">resource server</a></li>
<li><a href="#85716a8f-a45b-4829-81f3-031544a931a9">sender constraints</a></li>
<li><a href="#7f8d8d6d-54e2-4c00-8e1d-70d506be48c0">refresh token</a>
- <a href="#ee2b4b38-ef88-40f1-a285-e5b066e5f6b9">refresh token request</a>
- <a href="#7d849218-0f67-49ab-947d-8825efb7fbca">refresh token rotation</a></li>
<li><a href="#26052c2d-ac4a-4637-9122-704d51585dc8">access token</a>
<ul>
<li><a href="#d0d4bb6b-6c0e-404a-ae24-09b9e325aabf">use different lifetimes for your access tokens depending on the criticality of the scope</a></li>
<li><a href="#a352209c-f72b-4249-89d2-ce2581f96401">short lived</a></li>
</ul>
</li>
<li><a href="#12a2a69e-37e2-4532-bfbb-70c65dda6cf6">token instrospection</a></li>
<li><a href="#9dc87298-be54-4fd6-af23-1b9e640e84b7">kinds of token</a>
<ul>
<li><a href="#67203a0a-019d-4214-ada9-9b5e4eb2af32">reference token vs self-encoded access token</a>
<ul>
<li><a href="#dd6d7682-1dbe-4793-9890-62ac75b15a8a">use an API Gateway</a></li>
</ul>
</li>
<li><a href="#f71b3aee-6bbf-4f86-821d-466023c8386f">reference token</a></li>
<li><a href="#eec4cf73-015a-4574-beb5-f6c95445dfa7">self-encoded access tokens</a></li>
<li><a href="#5d9fcc89-c31e-43ed-a53f-b548eb688999">bearer token</a></li>
</ul>
</li>
<li><a href="#f86ccef1-e4b1-413f-b78c-8070f4dceafa">oauth 2.0 client</a>
<ul>
<li><a href="#5a660aaa-dc0c-43dc-8791-8fc47ca3e895">third party client</a></li>
<li><a href="#28c0dea8-7e16-4a73-8029-d99422f0142f">two kinds of client</a>
<ul>
<li><a href="#118410f7-3339-4794-8107-b03880897104">public client</a></li>
<li><a href="#12b392a5-8463-44e4-b3ef-e61b4c90e47c">confidential</a></li>
</ul>
</li>
<li><a href="#d961c0b3-9f25-4ba7-91cc-bae3f100d997">client id</a></li>
<li><a href="#6f4dbac8-544f-4be9-b9ee-8a42353caa90">client secret</a>
<ul>
<li><a href="#1730c1b2-9716-4fe3-b3b7-a9455174fdc1">do we really need client_secret to get access_token on PKCE flow?</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#88493c43-843b-4eb5-9074-57a4aa814ea5">OAuth 2.0 access token response</a></li>
<li><a href="#f691f972-8a34-4c8f-919e-f6fe29b9ae45">types of attack</a>
<ul>
<li><a href="#2d571b96-bc66-47f1-8efb-822acf452823">misuse of access token to impersonate resource owner in implicit flow</a></li>
</ul>
</li>
<li><a href="#notes-linking-here">Notes linking here</a></li>
<li><a href="#permalink">Permalink</a></li>
</ul>
</div>
<!--endtoc-->
<ul>
<li>External reference: <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-10.3">https://datatracker.ietf.org/doc/html/rfc6749#section-10.3</a></li>
<li>External reference: <a href="https://auth0.com/intro-to-iam/what-is-oauth-2/">https://auth0.com/intro-to-iam/what-is-oauth-2/</a></li>
<li>External reference: <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></li>
<li>External reference: <a href="https://www.oauth.com/oauth2-servers/access-tokens/access-token-lifetime/">https://www.oauth.com/oauth2-servers/access-tokens/access-token-lifetime/</a></li>
<li>External reference: <a href="https://www.oauth.com/oauth2-servers/access-tokens/self-encoded-access-tokens/">https://www.oauth.com/oauth2-servers/access-tokens/self-encoded-access-tokens/</a></li>
<li>External reference: <a href="https://datatracker.ietf.org/doc/html/rfc7523">https://datatracker.ietf.org/doc/html/rfc7523</a></li>
<li>External reference: <a href="https://oauth.net/2/">https://oauth.net/2/</a></li>
<li>External reference: <a href="https://oauth.net/2/jwt/">https://oauth.net/2/jwt/</a></li>
</ul>
<p>OAuth stands for open authorization. There are a lot of specifications made by
OAuth guys, but when people talk about OAuth2, they generally mean the initial
specification created in 2012: OAuth 2.0 authorization framework (a.k.a. RFC
6749). This RFC defines the authorization delegation flows and defines the four
roles (a <a href="#f86ccef1-e4b1-413f-b78c-8070f4dceafa">client</a> that gets granted access by an <a href="#ead7dfac-e39a-4262-8066-a9e594d1b8a3">authorization server</a> of resources
belonging to a <a href="/braindump/posts/resource_owner/">resource owner</a> and stored in a <a href="#72564685-ad13-4af1-8a9a-8230b967a36b">resource server</a>) and concepts
(<a href="#5d9fcc89-c31e-43ed-a53f-b548eb688999">bearer token</a>, <a href="#26052c2d-ac4a-4637-9122-704d51585dc8">access token</a>, <a href="#7f8d8d6d-54e2-4c00-8e1d-70d506be48c0">refresh token</a>, etc).</p>
<p>It seems like OAuth2 guys also invented <a href="/braindump/posts/json_web_tokens/">JWT</a> (a.k.a. RFC 7519).</p>
<p>It also seems like a lot of implementations have made use of JWT (and more
precisely <a href="/braindump/posts/json_web_signature/">JWS</a> and JWE compact serialisations) to encode the access token in a
<a href="#eec4cf73-015a-4574-beb5-f6c95445dfa7">self-encoded access tokens</a>.</p>
<p>Now, people tend to forget that the framework was defined with opaque <a href="#5d9fcc89-c31e-43ed-a53f-b548eb688999">bearer
token</a> in mind and that using a <a href="/braindump/posts/json_web_tokens/">JWT</a> encoded <a href="#26052c2d-ac4a-4637-9122-704d51585dc8">access token</a> is not part of the
initial spec.</p>
<p>This use of JWT everywhere appears to be the reason why OAuth guys came with
another RFC to try to specify a bit what should be put in those <a href="#eec4cf73-015a-4574-beb5-f6c95445dfa7">self-encoded
access tokens</a>. This RFC, called <a href="/braindump/posts/jwt_access_tokens_profile_for_oauth_2_0/">JWT Access Tokens for OAuth 2.0</a> (a.k.a. RFC9068)
is very young (October 2021) compared to the initial spec (October 2012). They
even suggest this in their website.<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<p>Also, people also tend to forget that OAuth is only about authorization and not
at all about <a href="/braindump/posts/authentication/">authentication</a>. Authentication is needed prior to authorize
anything, but OAuth does not say a thing about it. That is one of the reasons
why <a href="/braindump/posts/openid_connect/">OpenID Connect</a> exists. It is an extension that brings (among other things)
this missing piece: authentication. Because this is strongly related to the
notion of identity, it adds the concept of <a href="/braindump/posts/openid_connect/#6796313b-7141-4013-848f-bc08edd02472">Identity Token</a> (which is actually
specified to be JWT encoded, making people confuse it with a <a href="#eec4cf73-015a-4574-beb5-f6c95445dfa7">self-encoded access
tokens</a>). It also defined a few <a href="#90cbca1f-13ff-4f8d-9077-18722d75ae55">oauth 2.0 scope</a>s related to user&rsquo;s identity (like
openid).</p>
<p>In contrast to OAuth 2.0 access token, which is supposed to be opaque from the
<a href="#f86ccef1-e4b1-413f-b78c-8070f4dceafa">client</a> point of view, the <a href="/braindump/posts/openid_connect/#6796313b-7141-4013-848f-bc08edd02472">ID Token</a> is meant to be read by this role. See <a href="/braindump/posts/id_tokens_vs_access_tokens/">ID
Tokens vs Access Tokens</a>.</p>
<p>Nothing is said in OAuth about how the resource server and the client should
link resources to <a href="#eec4cf73-015a-4574-beb5-f6c95445dfa7">self-encoded access tokens</a> <a href="/braindump/posts/json_web_tokens/#121be43a-fc33-4942-9abe-9e9a5c2d426e">claims</a>.</p>
<p>The classical flow of OAuth 2.0 ensures that the client and resource servers
won&rsquo;t ever see the users credentials.<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></p>
<p>The other flows are tailored to specific use cases and try to make sensible
compromises on security.</p>
<blockquote>
<p>The OAuth 2.0 authorization framework enables a <a href="#02c86448-ca36-4995-b93e-fec4967b3b9c">third-party</a>
application to obtain limited access to an HTTP service</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>OAuth defines four roles:</p>
<dl>
<dt>resource owner</dt>
<dd>An entity capable of granting access to a protected resource.
When the resource owner is a person, it is referred to as an
end-user.</dd>
<dt>resource server</dt>
<dd>The server hosting the protected resources, capable of accepting
and responding to protected resource requests using access tokens.</dd>
<dt>client</dt>
<dd>An application making protected resource requests on behalf of the
resource owner and with its authorization.  The term &ldquo;client&rdquo; does
not imply any particular implementation characteristics (e.g.,
whether the application executes on a server, a desktop, or other
devices).</dd>
<dt>authorization server</dt>
<dd>The server issuing access tokens to the client after successfully
authenticating the resource owner and obtaining authorization.</dd>
</dl>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-1.1">https://datatracker.ietf.org/doc/html/rfc6749#section-1.1</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<figure><img src="https://konubinix.eu/ipfs/bafkreicv6wlk54ummx4afiso2hemrq4fcx7f4atys4zkhgcuh4sqinymxm?filename=a.png">
</figure>

<ul>
<li>
<p>(A) The client requests authorization from the resource owner.  The
authorization request can be made directly to the resource owner (as shown),
or preferably indirectly via the authorization server as an intermediary.</p>
</li>
<li>
<p>(B) The client receives an authorization grant, which is a credential
representing the resource owner&rsquo;s authorization, expressed using one of four
grant types defined in this specification or using an extension grant type.
The authorization grant type depends on the method used by the client to
request authorization and the types supported by the authorization server.</p>
</li>
<li>
<p>(C) The client requests an access token by authenticating with the
authorization server and presenting the authorization grant.</p>
</li>
<li>
<p>(D) The authorization server authenticates the client and validates the
authorization grant, and if valid, issues an access token.</p>
</li>
<li>
<p>(E) The client requests the protected resource from the resource server and
authenticates by presenting the access token.</p>
</li>
<li>
<p>(F) The resource server validates the access token, and if valid, serves the
request.</p>
</li>
</ul>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>OAuth defines two client types, based on their ability to
authenticate securely with the authorization server (i.e., ability to
maintain the confidentiality of their client credentials):</p>
<p>confidential
Clients capable of maintaining the confidentiality of their
credentials (e.g., client implemented on a secure server with
restricted access to the client credentials), or capable of secure
client authentication using other means.</p>
<p>public
Clients incapable of maintaining the confidentiality of their
credentials (e.g., clients executing on the device used by the
resource owner, such as an installed native application or a web
browser-based application), and incapable of secure client
authentication via any other means.</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<dl>
<dt>web application</dt>
<dd>A web application is a confidential client running on a web
server.  Resource owners access the client via an HTML user
interface rendered in a user-agent on the device used by the
resource owner.  The client credentials as well as any access
token issued to the client are stored on the web server and are
not exposed to or accessible by the resource owner.</dd>
<dt>user-agent-based application</dt>
<dd>A user-agent-based application is a public client in which the
client code is downloaded from a web server and executes within a
user-agent (e.g., web browser) on the device used by the resource
owner.  Protocol data and credentials are easily accessible (and
often visible) to the resource owner.  Since such applications
reside within the user-agent, they can make seamless use of the
user-agent capabilities when requesting authorization.</dd>
<dt>native application</dt>
<dd>A native application is a public client installed and executed on
the device used by the resource owner.  Protocol data and
credentials are accessible to the resource owner.  It is assumed
that any client authentication credentials included in the
application can be extracted.  On the other hand, dynamically
issued credentials such as access tokens or refresh tokens can
receive an acceptable level of protection.  At a minimum, these
credentials are protected from hostile servers with which the
application may interact.  On some platforms, these credentials
might be protected from other applications residing on the same
device.</dd>
</dl>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>The authorization server issues the registered client a client
identifier &ndash; a unique string representing the registration
information provided by the client.  The client identifier is not a
secret; it is exposed to the resource owner and MUST NOT be used
alone for client authentication.  The client identifier is unique to
the authorization server.</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>The token may denote an identifier used to retrieve the authorization
information or may self-contain the authorization information in a
verifiable manner (i.e., a token string consisting of some data and a
signature).  Additional authentication credentials, which are beyond
the scope of this specification, may be required in order for the
client to use a token</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>This specification makes extensive use of HTTP redirections, in which
the client or the authorization server directs the resource owner&rsquo;s
user-agent to another destination.</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>This specification defines four grant types:</p>
<ol>
<li>authorization code,</li>
<li>implicit,</li>
<li>resource owner password credentials,</li>
<li>and client credentials</li>
</ol>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>An authorization grant is a credential representing the resource
owner&rsquo;s authorization (to access its protected resources) used by the
client to obtain an access token</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>The resource owner password credentials (i.e., username and password)
can be used directly as an authorization grant to obtain an access
token.</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>The credentials should only be used when there is a high
degree of trust between the resource owner and the client (e.g., the
client is part of the device operating system or a highly privileged
application), and when other authorization grant types are not
available (such as an authorization code)</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>This
grant type can eliminate the need for the client to store the
resource owner credentials for future use, by exchanging the
credentials with a long-lived access token or refresh token.</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>The client credentials (or other forms of client authentication) can
be used as an authorization grant when the authorization scope is
limited to the protected resources under the control of the client</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>When choosing between the implicit grant type and the authorization
code grant type, the following should be considered:</p>
<p>o  Native applications that use the authorization code grant type
SHOULD do so without using client credentials, due to the native
application&rsquo;s inability to keep client credentials confidential.</p>
<p>o  When using the implicit grant type flow, a refresh token is not
returned, which requires repeating the authorization process once
the access token expires.</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>Authorization codes operate as plaintext bearer credentials, used to
verify that the resource owner who granted authorization at the
authorization server is the same resource owner returning to the
client to complete the process.</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>Authorization codes MUST be short lived and single-use.</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>Unlike access tokens, refresh tokens are intended for use only with
authorization servers and are never sent to resource servers.</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<figure><img src="https://konubinix.eu/ipfs/bafkreidftqako2auo6hmwuxyesfistwsa4iy2g6axxo4yirso4m2jfvala?filename=a.png">
</figure>

<ul>
<li>
<p>(A) The client requests an access token by authenticating with the
authorization server and presenting an authorization grant.</p>
</li>
<li>
<p>(B) The authorization server authenticates the client and validates the
authorization grant, and if valid, issues an access token and a refresh token.</p>
</li>
<li>
<p>(C) The client makes a protected resource request to the resource server by
presenting the access token.</p>
</li>
<li>
<p>(D) The resource server validates the access token, and if valid, serves the
request.</p>
</li>
<li>
<p>(E) Steps (C) and (D) repeat until the access token expires.  If the client
knows the access token expired, it skips to step (G); otherwise, it makes
another protected resource request.</p>
</li>
<li>
<p>(F) Since the access token is invalid, the resource server returns an invalid
token error.</p>
</li>
<li>
<p>(G) The client requests a new access token by authenticating with the
authorization server and presenting the refresh token.  The client
authentication requirements are based on the client type and on the
authorization server policies.</p>
</li>
<li>
<p>(H) The authorization server authenticates the client and validates the
refresh token, and if valid, issues a new access token (and, optionally, a new
refresh token).</p>
</li>
</ul>
<p>Steps (C), (D), (E), and (F) are outside the scope of this
specification, as described in Section 7.</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>This specification does not provide any methods for the resource
server to ensure that an access token presented to it by a given
client was issued to that client by the authorization server</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-10.3">https://datatracker.ietf.org/doc/html/rfc6749#section-10.3</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>ability to send request parameters in a JSON Web Token (JWT) instead, which
allows the request to be signed with JSON Web Signature (JWS) and encrypted with
JSON Web Encryption (JWE) so that the integrity, source authentication, and
confidentiality properties of the authorization request are attained. The
request can be sent by value or by reference</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc9101">https://datatracker.ietf.org/doc/html/rfc9101</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>This specification defines the use of a JSON Web Token (JWT) Bearer
Token as a means for requesting an OAuth 2.0 access token as well as
for client authentication.</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc7523">https://datatracker.ietf.org/doc/html/rfc7523</a></p>
</blockquote>
<h2 id="02c86448-ca36-4995-b93e-fec4967b3b9c">third-party vs first-party</h2>
<p>The <a href="#f86ccef1-e4b1-413f-b78c-8070f4dceafa">client</a> IS a third party, hence a party that is from an organization
different than the one owning the resources.</p>
<p>This RFC takes this into account in its security model. In the case of a
first-party, where the client and the resource owner belong to the same
organization, there are several aspects of the rfc that you don&rsquo;t need, like
the <a href="#1d0956e3-43f6-44fb-9f18-a19c69980b1e">user consent screen</a> or even the need for a delegated authorization scheme
like oauth2. In that case, using <a href="/braindump/posts/openid_connect/">OIDC</a>, and passing only the <a href="/braindump/posts/openid_connect/#6796313b-7141-4013-848f-bc08edd02472">ID Token</a> as
authentication proof, may be enough.</p>
<h2 id="90cbca1f-13ff-4f8d-9077-18722d75ae55">scope</h2>
<h2 id="7b976efb-d964-4d48-acb7-1974de405bcc">what is not <a href="/braindump/posts/oauth_2_0/">OAuth 2.0</a> is not useless or a bad idea</h2>
<p>It&rsquo;s just not supported by a group of people that have spent more than 10 years
trying to define something secure.</p>
<p>For instance, you might have a good flow based on the <a href="#e296ff6e-e206-4d1e-840e-1971682b45e2">implicit grant</a>. It&rsquo;s just not oauth anymore.</p>
<p>For example, <a href="/braindump/posts/openid_connect/">OpenID Connect</a> provide something very similar to the
implicit grant, with a way to validate the access token using its hash in the
<a href="/braindump/posts/openid_connect/#6796313b-7141-4013-848f-bc08edd02472">id token</a>.</p>
<h2 id="b0c592a9-32eb-468c-b342-962e6ab44d48">the purpose of <a href="/braindump/posts/oauth_2_0/">OAuth 2.0</a> was to avoid that the <a href="#f86ccef1-e4b1-413f-b78c-8070f4dceafa">client oauth 2.0</a> sees the <a href="/braindump/posts/resource_owner/">resource owner</a>&rsquo;s password</h2>
<h2 id="1d0956e3-43f6-44fb-9f18-a19c69980b1e">user consent screen</h2>
<p>It is the human readable version of the <a href="#90cbca1f-13ff-4f8d-9077-18722d75ae55">oauth 2.0 scope</a>, so that the <a href="/braindump/posts/resource_owner/">resource owner</a> can give per <a href="/braindump/posts/consentement/">consent</a>.</p>
<h2 id="29bf253c-9d6a-4287-94a0-18403f092029">it starts with a <a href="#f86ccef1-e4b1-413f-b78c-8070f4dceafa">oauth 2.0 client</a> registering itself with a <a href="#ead7dfac-e39a-4262-8066-a9e594d1b8a3">authorization server</a></h2>
<h2 id="964ef238-3cbc-44aa-8fda-83d04ae41052">user agent</h2>
<p>Generally the web browser. The stuff used by the user to perform the
<a href="/braindump/posts/authentication/">authentication</a> and used, via <a href="/braindump/posts/http_redirection/">http redirection</a> to share the <a href="#65dc3014-485c-499c-937b-33cf88330b2f">authorization code</a>.</p>
<h2 id="134cb1c6-0fdb-420a-adae-c3e5e8f597f0">two modes of communication</h2>
<h3 id="116966da-935d-4b55-8275-25316ca48534">an ambiguity</h3>
<p>There were defined at a time (~2010) when only backend could make secure
connections. Therefore we need to remember that front channel actually means
with intermediary, insecure and back channel means end-to-end and encrypted.</p>
<p>A front end can totally make back channel communication as of today.</p>
<h4 id="e1507f32-33af-486a-b122-e38846bd470c"><a href="#29459edd-a5f0-407f-9457-54e30455bac7">front channel</a> is about UI and the <a href="#9f31519d-b4cf-49c6-8209-ddb2458bcb91">back channel</a> is about converting the outcome of the frontchannel to tokens</h4>
<p>The front channel is insecure and not trustworthy to send data between the
<a href="#ead7dfac-e39a-4262-8066-a9e594d1b8a3">authorization server</a> and the <a href="#f86ccef1-e4b1-413f-b78c-8070f4dceafa">oauth 2.0 client</a>. Yet it is the only
way so far to make the <a href="/braindump/posts/resource_owner/">resource owner</a> be part of this triangle communication and give per <a href="#1d0956e3-43f6-44fb-9f18-a19c69980b1e">consent</a></p>
<h3 id="9f31519d-b4cf-49c6-8209-ddb2458bcb91">back channel</h3>
<p>A secure (meaning https) end to end communication.</p>
<p>For instance, it is the way the <a href="#65dc3014-485c-499c-937b-33cf88330b2f">authorization code</a> is shared between the <a href="#ead7dfac-e39a-4262-8066-a9e594d1b8a3">authorization server</a> and the <a href="#f86ccef1-e4b1-413f-b78c-8070f4dceafa">oauth 2.0 client</a>.</p>
<ul>
<li>see,
<ul>
<li><a href="#29459edd-a5f0-407f-9457-54e30455bac7">front channel</a>,</li>
</ul>
</li>
</ul>
<h3 id="29459edd-a5f0-407f-9457-54e30455bac7">front channel</h3>
<p>A less secure way of sharing information than the <a href="#9f31519d-b4cf-49c6-8209-ddb2458bcb91">back channel</a>, where the
<a href="#964ef238-3cbc-44aa-8fda-83d04ae41052">user agent</a> is involved to share some information, like a mailman between two parties.</p>
<p>For instance, the <a href="#65dc3014-485c-499c-937b-33cf88330b2f">authorization code</a> is issued by the <a href="#ead7dfac-e39a-4262-8066-a9e594d1b8a3">authorization server</a> to
the <a href="#f86ccef1-e4b1-413f-b78c-8070f4dceafa">oauth 2.0 client</a> using a <a href="/braindump/posts/http_redirection/">302 response</a>.</p>
<p>The <a href="#964ef238-3cbc-44aa-8fda-83d04ae41052">user agent</a> being a <a href="/braindump/posts/man_in_the_middle/">man in the middle</a>, there is no way for the
<a href="#ead7dfac-e39a-4262-8066-a9e594d1b8a3">authorization server</a> to find out whether the <a href="#f86ccef1-e4b1-413f-b78c-8070f4dceafa">oauth 2.0 client</a> actually
correctly received appropriate data and for the <a href="#f86ccef1-e4b1-413f-b78c-8070f4dceafa">oauth 2.0 client</a> to find out
whether the data got from the <a href="#ead7dfac-e39a-4262-8066-a9e594d1b8a3">authorization server</a> is the correct one.</p>
<p>Also, there is no certainty that the data in the url did not got spoofed and
used by the spoofer. Therefore, the <a href="#e296ff6e-e206-4d1e-840e-1971682b45e2">implicit grant</a>, with all the extensions
like the browser syncing ones that save and reuse the browser history, is not
deprecated.</p>
<p>Fortunately, the <a href="/braindump/posts/oauth_2_1/#b8a57c75-44c9-4f89-a88e-635bcb618246">authorization code grant with PKCE</a> mitigates this issue.</p>
<h4 id="919d41f4-704d-4170-9eac-5d6ed74ce331">metaphor of the wall</h4>
<p>It is like the <a href="#29459edd-a5f0-407f-9457-54e30455bac7">frontchannel</a> is a wall and you send stuff to the other side.</p>
<p>You cannot tell whether someoen got it and whether this someone is actually the
appropriate recipient.</p>
<p>Also, the recipient cannot tell whether the stuff that is thrown above the wall
comes from the appropriate sender.</p>
<h2 id="ffcfb38c-79eb-446e-a10c-e39c5b2e45fa">cross jwt confusion</h2>
<ul>
<li>
<p>External reference: <a href="https://datatracker.ietf.org/doc/html/rfc8725#section-3.9">https://datatracker.ietf.org/doc/html/rfc8725#section-3.9</a>
See also <a href="#2d571b96-bc66-47f1-8efb-822acf452823">misuse of access token to impersonate resource owner in implicit flow</a></p>
<blockquote>
<p>As <a href="/braindump/posts/json_web_tokens/">JWTs</a> are being used by more different protocols in diverse
application areas, it becomes increasingly important to prevent cases
of JWT tokens that have been issued for one purpose being subverted
and used for another.  Note that this is a specific type of
substitution attack.  If the JWT could be used in an application
context in which it could be confused with other kinds of JWTs, then
mitigations MUST be employed to prevent these substitution attacks.</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc8725#section-2.8">https://datatracker.ietf.org/doc/html/rfc8725#section-2.8</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>the JWT MUST contain an &ldquo;aud&rdquo; (<a href="/braindump/posts/audience_claim/">audience</a>) claim that can be used to determine
whether the JWT is being used by an intended party or was substituted by an
attacker at an unintended party.</p>
<p>In such cases, the relying party or application MUST validate the
audience value, and if the audience value is not present or not
associated with the recipient, it MUST reject the JWT.</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc8725#section-3.9">https://datatracker.ietf.org/doc/html/rfc8725#section-3.9</a></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>To prevent substitution of JWTs from one context into another, application
developers may employ a number of strategies:</p>
<ul>
<li>Use explicit typing for different kinds of JWTs.  Then the distinct &ldquo;typ&rdquo;
values can be used to differentiate between the different kinds of JWTs.</li>
<li>Use different sets of required claims or different required claim values.
Then the validation rules for one kind of JWT will reject those with different
claims or values.</li>
<li>Use different sets of required Header Parameters or different required Header
Parameter values.  Then the validation rules for one kind of JWT will reject
those with different Header Parameters or values.</li>
<li>Use different keys for different kinds of JWTs.  Then the keys used to
validate one kind of JWT will fail to validate other kinds of JWTs.</li>
<li>Use different &ldquo;aud&rdquo; values for different uses of JWTs from the same issuer.
Then audience validation will reject JWTs substituted into inappropriate
contexts.</li>
<li>Use different issuers for different kinds of JWTs.  Then the distinct &ldquo;iss&rdquo;
values can be used to segregate the different kinds of JWTs.</li>
</ul>
<p>Given the broad diversity of JWT usage and applications, the best combination of
types, required claims, values, Header Parameters, key usages, and issuers to
differentiate among different kinds of JWTs will, in general, be
application-specific.</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc8725#section-3.12">https://datatracker.ietf.org/doc/html/rfc8725#section-3.12</a></p>
</blockquote>
<h2 id="1c5ce2b0-1b28-4f35-8978-3ba8acd027b0">5 types of grant -&gt; <a href="/braindump/posts/oauth_2_1/#1ea6bc5b-42cc-4f26-b8ff-199269676e6f">now only 2</a></h2>
<h3 id="def201dd-26c7-44f9-8456-ad5d3c631731">authorization code grant</h3>
<blockquote>
<p>The client constructs the request URI by adding the following
parameters to the query component of the authorization endpoint URI
using the &ldquo;application/x-www-form-urlencoded&rdquo; format, per Appendix B:</p>
<dl>
<dt>response_type</dt>
<dd>REQUIRED.  Value MUST be set to &ldquo;code&rdquo;.</dd>
<dt>client_id</dt>
<dd>REQUIRED.  The client identifier as described in Section 2.2.</dd>
<dt>redirect_uri</dt>
<dd>OPTIONAL.  As described in Section 3.1.2.</dd>
<dt>scope</dt>
<dd>OPTIONAL.  The scope of the access request as described by Section 3.3</dd>
<dt>state</dt>
<dd>RECOMMENDED.  An opaque value used by the client to maintain state
between the request and callback.  The authorization server includes this
value when redirecting the user-agent back to the client.  The parameter
SHOULD be used for preventing cross-site request forgery as described in
Section 10.12.</dd>
</dl>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-4.1">https://datatracker.ietf.org/doc/html/rfc6749#section-4.1</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>Authorization Code Flow returns an Authorization Code to the Client, which can
then exchange it for an ID Token and an Access Token directly. This provides the
benefit of not exposing any tokens to the User Agent and possibly other
malicious applications with access to the User Agent</p>
<p>&mdash; <a href="https://openid.net/specs/openid-connect-core-1_0.html#Introduction">https://openid.net/specs/openid-connect-core-1_0.html#Introduction</a></p>
</blockquote>
<h4 id="63bc2c1a-054f-423d-9233-c4673892c57d">access token request</h4>
<ul>
<li>
<p>External reference: <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.3">https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.3</a></p>
<blockquote>
<p>The client makes a request to the token endpoint by sending the
following parameters using the &ldquo;application/x-www-form-urlencoded&rdquo;
format per Appendix B with a character encoding of UTF-8 in the HTTP
request entity-body:</p>
<p>grant_type
REQUIRED.  Value MUST be set to &ldquo;authorization_code&rdquo;.</p>
<p>code
REQUIRED.  The authorization code received from the
authorization server.</p>
<p>redirect_uri
REQUIRED, if the &ldquo;redirect_uri&rdquo; parameter was included in the
authorization request as described in Section 4.1.1, and their
values MUST be identical.</p>
<p>client_id
REQUIRED, if the client is not authenticating with the
authorization server as described in Section 3.2.1.</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.3">https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.3</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded</p>
<p>grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA
&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.3">https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.3</a></p>
</blockquote>
</li>
</ul>
<h4 id="65dc3014-485c-499c-937b-33cf88330b2f">authorization code</h4>
<h3 id="e0103c93-f693-4883-b331-b1ecb8ef88a0">password grant</h3>
<ul>
<li>
<p>External reference: <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-4.3">https://datatracker.ietf.org/doc/html/rfc6749#section-4.3</a></p>
<blockquote>
<p>Is it appropriate to use resource owner password credential grant type.</p>
<p>The short answer is never</p>
<p>&mdash; <a href="/braindump/posts/nat_sakimura/">Nat Sakimura</a> (<a href="https://youtube.com/watch?v=qMtYaDmhnHU&amp;t=4.65s">https://youtube.com/watch?v=qMtYaDmhnHU&amp;t=4.65s</a>)</p>
</blockquote>
</li>
</ul>
<h3 id="e296ff6e-e206-4d1e-840e-1971682b45e2">implicit grant</h3>
<ul>
<li>
<p>External reference: <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-4.2">https://datatracker.ietf.org/doc/html/rfc6749#section-4.2</a></p>
<blockquote>
<p>Authorization Request</p>
<p>The client constructs the request URI by adding the following
parameters to the query component of the authorization endpoint URI
using the &ldquo;application/x-www-form-urlencoded&rdquo; format, per Appendix B:</p>
<dl>
<dt>response_type</dt>
<dd>REQUIRED.  Value MUST be set to &ldquo;token&rdquo;.</dd>
<dt>client_id</dt>
<dd>REQUIRED.  The client identifier as described in Section 2.2.</dd>
<dt>redirect_uri</dt>
<dd>OPTIONAL.  As described in Section 3.1.2.</dd>
<dt>scope</dt>
<dd>OPTIONAL.  The scope of the access request as described by Section 3.3</dd>
<dt>state</dt>
<dd>RECOMMENDED.  An opaque value used by the client to maintain state
between the request and callback.  The authorization server includes this
value when redirecting the user-agent back to the client.  The parameter
SHOULD be used for preventing cross-site request forgery as described in
Section 10.12.</dd>
</dl>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-4.2">https://datatracker.ietf.org/doc/html/rfc6749#section-4.2</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>example, the client directs the user-agent to make the following
HTTP request using TLS (with extra line breaks for display purposes
only):</p>
<p>GET /authorize?response_type=token&amp;client_id=s6BhdRkqt3&amp;state=xyz
&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
Host: server.example.com</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-4.2">https://datatracker.ietf.org/doc/html/rfc6749#section-4.2</a></p>
</blockquote>
</li>
</ul>
<h2 id="a86c2b04-58d7-48fc-947f-b199e5b9d3f0">What is an <a href="#26052c2d-ac4a-4637-9122-704d51585dc8">Access Token</a>?</h2>
<ul>
<li>
<p>External reference: <a href="https://oauth.net/2/access-tokens/">https://oauth.net/2/access-tokens/</a>
What is an Access Token - OAuth 2.0</p>
<blockquote>
<p>OAuth Access Token is a string that the OAuth client uses to make requests to the resource server.</p>
<p>&mdash; <a href="https://oauth.net/2/access-tokens/">https://oauth.net/2/access-tokens/</a></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>Access tokens do not have to be in any particular format, and in practice,
various OAuth servers have chosen many different formats for their access
tokens</p>
<p>&mdash; <a href="https://oauth.net/2/access-tokens/">https://oauth.net/2/access-tokens/</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>Access tokens may be either &ldquo;bearer tokens&rdquo; or &ldquo;sender-constrained&rdquo;
tokens. Sender-constrained tokens require the OAuth client to prove possession
of a private key in some way in order to use the access token, such that the
access token by itself would not be usable</p>
<p>&mdash; <a href="https://oauth.net/2/access-tokens/">https://oauth.net/2/access-tokens/</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>Access tokens must not be read or interpreted by the OAuth client. The OAuth
client is not the intended audience of the token.</p>
<p>&mdash; <a href="https://oauth.net/2/access-tokens/">https://oauth.net/2/access-tokens/</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>Access tokens should only be used to make requests to the resource server</p>
<p>&mdash; <a href="https://oauth.net/2/access-tokens/">https://oauth.net/2/access-tokens/</a></p>
</blockquote>
<h2 id="ead7dfac-e39a-4262-8066-a9e594d1b8a3">authorization server</h2>
<h3 id="1e5b1c0a-9021-402a-9274-0151b47cb349">authorization request</h3>
<h4 id="a37efbc7-01c6-4f37-96be-524bf9ea223b">Rich Authorization Requests</h4>
<ul>
<li>
<p>External reference: <a href="https://datatracker.ietf.org/doc/html/draft-ietf-oauth-rar">https://datatracker.ietf.org/doc/html/draft-ietf-oauth-rar</a>
<a href="/braindump/posts/oauth_2_0/">OAuth 2.0</a>, <a href="#1d0956e3-43f6-44fb-9f18-a19c69980b1e">user consent screen</a>, <a href="#90cbca1f-13ff-4f8d-9077-18722d75ae55">oauth 2.0 scope</a></p>
<blockquote>
<p>implement static scenarios and coarse-grained authorization requests, such as
&ldquo;give me read access to the resource owner&rsquo;s profile&rdquo; but it is not sufficient
to specify fine-grained authorization requirements, such as &ldquo;please let me
transfer an amount of 45 Euros to Merchant A&rdquo; or &ldquo;please give me read access to
directory A and write access to file X&rdquo;.</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/draft-ietf-oauth-rar#name-introduction">https://datatracker.ietf.org/doc/html/draft-ietf-oauth-rar#name-introduction</a></p>
</blockquote>
</li>
</ul>
<h4 id="763e874e-ad40-489f-8a13-b1e47cf26d63">JWT-Secured Authorization Request</h4>
<ul>
<li>External reference: <a href="https://datatracker.ietf.org/doc/html/rfc9101">https://datatracker.ietf.org/doc/html/rfc9101</a>
<a href="/braindump/posts/oauth_2_0/">OAuth 2.0</a>, <a href="#a37efbc7-01c6-4f37-96be-524bf9ea223b">RAR</a>,</li>
</ul>
<blockquote>
<p>authorization request in OAuth 2.0 described in RFC 6749 utilizes
query parameter serialization</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc9101">https://datatracker.ietf.org/doc/html/rfc9101</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>This document introduces the ability to send request parameters in a
JSON Web Token (JWT) instead</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc9101">https://datatracker.ietf.org/doc/html/rfc9101</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>allows the request to be signed
with JSON Web Signature (JWS) and encrypted with JSON Web Encryption
(JWE) so that the integrity, source authentication, and
confidentiality properties of the authorization request are attained</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc9101">https://datatracker.ietf.org/doc/html/rfc9101</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>ability to send request parameters in a JSON Web Token (JWT) instead, which
allows the request to be signed with JSON Web Signature (JWS) and encrypted with
JSON Web Encryption (JWE) so that the integrity, source authentication, and
confidentiality properties of the authorization request are attained. The
request can be sent by value or by reference</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc9101">https://datatracker.ietf.org/doc/html/rfc9101</a></p>
</blockquote>
<h4 id="78f6fe2d-0be8-4706-9f15-03cc99923cde">Pushed Authorization Requests</h4>
<ul>
<li>
<p>External reference: <a href="https://datatracker.ietf.org/doc/html/rfc9126">https://datatracker.ietf.org/doc/html/rfc9126</a>
<a href="/braindump/posts/oauth_2_0/">OAuth 2.0</a>, <a href="#763e874e-ad40-489f-8a13-b1e47cf26d63">JAR</a>, <a href="#a37efbc7-01c6-4f37-96be-524bf9ea223b">RAR</a></p>
<blockquote>
<p>pushed authorization request (PAR) endpoint, which allows clients to push
the payload of an OAuth 2.0 authorization request to the authorization
server via a direct request and provides them with a request URI that is
used as reference to the data in a subsequent call to the authorization
endpoint.</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc9126">https://datatracker.ietf.org/doc/html/rfc9126</a></p>
</blockquote>
</li>
</ul>
<h2 id="06528c1b-08f2-437a-86e3-890587ec0199">the <a href="/braindump/posts/resource_owner/">resource owner</a> needs to know the <a href="#ead7dfac-e39a-4262-8066-a9e594d1b8a3">authorization server</a> and trust it</h2>
<p>This is the entity that will gets the user password and provide the <a href="#1d0956e3-43f6-44fb-9f18-a19c69980b1e">user consent screen</a>. A trust relationship between those entities is needed.</p>
<h2 id="72564685-ad13-4af1-8a9a-8230b967a36b">resource server</h2>
<ul>
<li>External reference: <a href="https://datatracker.ietf.org/doc/html/rfc8725#section-3.12">https://datatracker.ietf.org/doc/html/rfc8725#section-3.12</a></li>
</ul>
<h2 id="85716a8f-a45b-4829-81f3-031544a931a9">sender constraints</h2>
<blockquote>
<p>&ldquo;Sender constraint&rdquo; indicates a series of techniques that bind tokens to a particular sender</p>
<p>&mdash; <a href="https://auth0.com/blog/identity-unlocked-explained-episode-1/">https://auth0.com/blog/identity-unlocked-explained-episode-1/</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>two different specifications in the OAuth 2 family offering viable sender
constraint capabilities today: OAuth 2.0 Mutual TLS Client Authentication and
Certificate-Bound Access Tokens (MTLS, RFC8705) and OAuth 2.0 Demonstration of
Proof-of-Possession at the Application Layer (DPoP).</p>
<p>&mdash; <a href="https://auth0.com/blog/identity-unlocked-explained-episode-1/">https://auth0.com/blog/identity-unlocked-explained-episode-1/</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>MTLS is robust and stable, but not easy to implement</p>
<p>&mdash; <a href="https://auth0.com/blog/identity-unlocked-explained-episode-1/">https://auth0.com/blog/identity-unlocked-explained-episode-1/</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>DPoP quickly emerged as an easy to implement an alternative</p>
<p>&mdash; <a href="https://auth0.com/blog/identity-unlocked-explained-episode-1/">https://auth0.com/blog/identity-unlocked-explained-episode-1/</a></p>
</blockquote>
<h2 id="7f8d8d6d-54e2-4c00-8e1d-70d506be48c0">refresh token</h2>
<blockquote>
<figure><img src="https://konubinix.eu/ipfs/bafkreifvhwkol546qwzfd7kbmgziuvxuazhkhxrlopoqybesocwlvs7pii?filename=a.png">
</figure>

<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>Unlike access tokens, refresh tokens are
intended for use only with authorization servers and are never sent
to resource servers.</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>used to obtain a new access token when the current access token
becomes invalid or expires, or to obtain additional access tokens
with identical or narrower scope</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>Refresh tokens are credentials used to obtain access tokens.</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<h4 id="ee2b4b38-ef88-40f1-a285-e5b066e5f6b9">refresh token request</h4>
<ul>
<li>
<p>External reference: <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-6">https://datatracker.ietf.org/doc/html/rfc6749#section-6</a></p>
<blockquote>
<p>If the authorization server issued a refresh token to the client, the
client makes a refresh request to the token endpoint by adding the
following parameters using the &ldquo;application/x-www-form-urlencoded&rdquo;
format per Appendix B with a character encoding of UTF-8 in the HTTP
request entity-body:</p>
<p>grant_type
REQUIRED.  Value MUST be set to &ldquo;refresh_token&rdquo;.</p>
<p>refresh_token
REQUIRED.  The refresh token issued to the client.</p>
<p>scope
OPTIONAL.  The scope of the access request as described by
Section 3.3.  The requested scope MUST NOT include any scope
not originally granted by the resource owner, and if omitted is
treated as equal to the scope originally granted by the
resource owner.</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-6">https://datatracker.ietf.org/doc/html/rfc6749#section-6</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded</p>
<p>grant_type=refresh_token&amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-6">https://datatracker.ietf.org/doc/html/rfc6749#section-6</a></p>
</blockquote>
</li>
</ul>
<h4 id="7d849218-0f67-49ab-947d-8825efb7fbca">refresh token rotation</h4>
<p>According to <a href="/braindump/posts/oauth_the_good_parts_anders_abel/">OAuth ‚Äì the good Parts - Anders Abel - NDC Oslo 2022</a>, refresh
tokens should be chained. Each refresh token should be for one time use only
and refreshing should issue another refresh token. That way, when you don&rsquo;t
manage to refresh, you know someone spoofed it and can invalidate all the
tokens made by this chain.</p>
<p>According to <a href="/braindump/posts/forget_about_oauth_2_0_here_comes_oauth_2_1_philippe_de_ryck_ndc_oslo_2022/">Forget about OAuth
2.0. Here comes OAuth 2.1 - Philippe De Ryck - NDC Oslo 2022</a>, this does
not prevent attacks. When an attacker gets access to the client code (using
<a href="/braindump/posts/cross_site_scripting/">XSS</a>), per can make the
application ping a remote server to make it know how long the client session is open.</p>
<p>When the remote server ceases to receive pings, it can simply use the last
refresh token. Per won&rsquo;t be bothered as long as the user keeps logged out.</p>
<p>See also <a href="/braindump/posts/oidc_silent_authentication/">OIDC Silent Authentication</a>.</p>
<blockquote>
<p>Auth0 recommends using <a href="#7d849218-0f67-49ab-947d-8825efb7fbca">refresh token rotation</a> which provides a secure method for
using refresh tokens in <a href="/braindump/posts/single_page_application/">SPA</a>s while providing end-users with seamless access to
resources without the disruption in UX caused by browser privacy technology like
ITP.</p>
<p>&mdash; <a href="https://auth0.com/docs/secure/tokens/refresh-tokens">https://auth0.com/docs/secure/tokens/refresh-tokens</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>technique for getting new access tokens using refresh tokens that goes beyond silent authentication.</p>
<p>&mdash; <a href="https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation">https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>Refresh tokens are often used in native applications on mobile devices in conjunction with short-lived access tokens to provide seamless UX without having to issue long-lived access tokens.</p>
<p>&mdash; <a href="https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation">https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>Until very recently, SPAs maintained the user‚Äôs session by using the Authorization Code Flow with PKCE in conjunction with silent authentication</p>
<p>&mdash; <a href="https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation">https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>Unfortunately, long-lived refresh tokens are not suitable for SPAs because there is no persistent storage mechanism in a browser that can assure access by the intended application only</p>
<p>&mdash; <a href="https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation">https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>using refresh tokens in SPAs has been strongly discouraged.</p>
<p>&mdash; <a href="https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation">https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>Refresh token rotation offers a remediation to end-user sessions being lost due to side-effects of browser privacy mechanisms. Because refresh token rotation does not rely on access to the Auth0 session cookie, it is not affected by ITP or similar mechanisms.</p>
<p>&mdash; <a href="https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation">https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>As soon as the new pair is issued by Auth0, the refresh token used in the request is invalidated. This safeguards your app from replay attacks resulting from compromised tokens.</p>
<p>&mdash; <a href="https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation">https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation</a></p>
</blockquote>
<h2 id="26052c2d-ac4a-4637-9122-704d51585dc8">access token</h2>
<blockquote>
<p>The access token provides an abstraction layer, replacing different
authorization constructs (e.g., username and password) with a single
token understood by the resource server.  This abstraction enables
issuing access tokens more restrictive than the authorization grant
used to obtain them, as well as removing the resource server&rsquo;s need
to understand a wide range of authentication methods.</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>access token is a string representing an authorization issued to the
client. The string is usually opaque to the client</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<p>It may be a <a href="#5d9fcc89-c31e-43ed-a53f-b548eb688999">bearer token</a>, provided in the <a href="/braindump/posts/authorization_request_header/">authorization header</a> as defined in <a href="https://datatracker.ietf.org/doc/html/rfc2617">https://datatracker.ietf.org/doc/html/rfc2617</a>.</p>
<h3 id="d0d4bb6b-6c0e-404a-ae24-09b9e325aabf">use different lifetimes for your access tokens depending on the criticality of the scope</h3>
<h3 id="a352209c-f72b-4249-89d2-ce2581f96401">short lived</h3>
<blockquote>
<p>need to make some decisions as to how long you want the tokens to
last. Unfortunately there is no blanket solution for every service</p>
<p>&mdash; <a href="https://www.oauth.com/oauth2-servers/access-tokens/access-token-lifetime/">https://www.oauth.com/oauth2-servers/access-tokens/access-token-lifetime/</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>common method of granting tokens is to use a combination of access tokens and refresh tokens for maximum security and flexibility. The OAuth 2.0 spec recommends this option, and several of the larger implementations have gone with this approach</p>
<p>&mdash; <a href="https://www.oauth.com/oauth2-servers/access-tokens/access-token-lifetime/">https://www.oauth.com/oauth2-servers/access-tokens/access-token-lifetime/</a></p>
</blockquote>
<h2 id="12a2a69e-37e2-4532-bfbb-70c65dda6cf6">token instrospection</h2>
<h2 id="9dc87298-be54-4fd6-af23-1b9e640e84b7">kinds of token</h2>
<h3 id="67203a0a-019d-4214-ada9-9b5e4eb2af32"><a href="#f71b3aee-6bbf-4f86-821d-466023c8386f">reference token</a> vs <a href="#eec4cf73-015a-4574-beb5-f6c95445dfa7">self-encoded access token</a></h3>
<table>
  <thead>
      <tr>
          <th>reference token</th>
          <th>self encoded access token</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>easy to invalidate</td>
          <td>needs to wait token expiration</td>
      </tr>
      <tr>
          <td>needs more authorization server calls</td>
          <td>only need to fetch the public key from time to time</td>
      </tr>
      <tr>
          <td>not easily confused with id token</td>
          <td>clients tend to feel legitimate looking into it</td>
      </tr>
      <tr>
          <td>needs to implement introspection in the resource server</td>
          <td>easier dev because the token contains all the needed information</td>
      </tr>
  </tbody>
</table>
<p>This looks like a simple comparison, but depending on the properties of the
<a href="#eec4cf73-015a-4574-beb5-f6c95445dfa7">self-encoded access token</a>, the comparison might less relevant. For instance,
the less the expiration time, the more the self encoded access token
resembles a reference token with regards to validity and authorization call
load.</p>
<p>Also, using <a href="/braindump/posts/json_web_encryption/">JWE</a>, one can make the token more <a href="/braindump/posts/is_the_bearer_token_opaque/">opaque</a> and mitigate the issue
with client looking where they should not.</p>
<h4 id="dd6d7682-1dbe-4793-9890-62ac75b15a8a">use an <a href="/braindump/posts/api_gateway/">API Gateway</a></h4>
<p>The <a href="/braindump/posts/api_gateway/">API Gateway</a> can, depending on the accessed data, decide to let the
<a href="#eec4cf73-015a-4574-beb5-f6c95445dfa7">self-encoded access token</a> go through or perform a <a href="#12a2a69e-37e2-4532-bfbb-70c65dda6cf6">token instrospection</a>
lookup to avoid the possibility of false positive (<a href="/braindump/posts/security_vs_user_experience_balance/">security vs user
experience balance</a>).</p>
<p>Is also provide a fast filter, allowing the domain logic to perform the
slower checks in fewer requests.</p>
<h3 id="f71b3aee-6bbf-4f86-821d-466023c8386f">reference token</h3>
<p>A token that does not contain useful information and needs to go through a
<a href="#12a2a69e-37e2-4532-bfbb-70c65dda6cf6">token instrospection</a> endpoint, as opposed to a <a href="#eec4cf73-015a-4574-beb5-f6c95445dfa7">self-encoded access token</a>.</p>
<h3 id="eec4cf73-015a-4574-beb5-f6c95445dfa7">self-encoded access tokens</h3>
<ul>
<li>External reference: <a href="https://www.oauth.com/oauth2-servers/access-tokens/self-encoded-access-tokens/">https://www.oauth.com/oauth2-servers/access-tokens/self-encoded-access-tokens/</a>
They are <a href="#26052c2d-ac4a-4637-9122-704d51585dc8">access token</a> that contain information so that there is no need to
consult a database to process them (as opposed to <a href="#f71b3aee-6bbf-4f86-821d-466023c8386f">reference token</a>). Because
they are signed by the <a href="#ead7dfac-e39a-4262-8066-a9e594d1b8a3">authorization server</a>, they can be relying upon. They
are in general encoded using <a href="/braindump/posts/json_web_tokens/">JWT</a> and serialized using <a href="/braindump/posts/json_web_signature/">JWS</a> if the data is no
sensitive, or <a href="/braindump/posts/json_web_encryption/">JWE</a> if the data is private.</li>
</ul>
<blockquote>
<p>The most common way to implement self-encoded tokens is to use the JWS spec,
creating a JSON-serialized representation of all the data you want to include
in the token, and signing the resulting string with a private key known only
to your authorization server.</p>
<p>&mdash; <a href="https://www.oauth.com/oauth2-servers/access-tokens/self-encoded-access-tokens/">https://www.oauth.com/oauth2-servers/access-tokens/self-encoded-access-tokens/</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>RFC 9068 defines a standard way to use JWTs as access tokens, based on the real-world deployment experience of a number of large OAuth providers.</p>
<p>&mdash; <a href="https://www.oauth.com/oauth2-servers/access-tokens/self-encoded-access-tokens/">https://www.oauth.com/oauth2-servers/access-tokens/self-encoded-access-tokens/</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>Because the token can be verified without doing a database lookup, there is no way to invalidate a token until it expires</p>
<p>&mdash; <a href="https://www.oauth.com/oauth2-servers/access-tokens/self-encoded-access-tokens/">https://www.oauth.com/oauth2-servers/access-tokens/self-encoded-access-tokens/</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>Self-encoded tokens provide a way to avoid storing tokens in a database by
encoding all of the necessary information in the token string itself</p>
<p>&mdash; <a href="https://www.oauth.com/oauth2-servers/access-tokens/self-encoded-access-tokens/">https://www.oauth.com/oauth2-servers/access-tokens/self-encoded-access-tokens/</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>API servers are able to verify access tokens without doing a database lookup on
every API request, making the API much more easily scalable</p>
<p>&mdash; <a href="https://www.oauth.com/oauth2-servers/access-tokens/self-encoded-access-tokens/">https://www.oauth.com/oauth2-servers/access-tokens/self-encoded-access-tokens/</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>benefit of OAuth 2.0 Bearer Tokens is that applications don‚Äôt need to be aware
of how you‚Äôve decided to implement access tokens in your service. This means
it‚Äôs possible to change your implementation later without affecting clients.</p>
<p>&mdash; <a href="https://www.oauth.com/oauth2-servers/access-tokens/self-encoded-access-tokens/">https://www.oauth.com/oauth2-servers/access-tokens/self-encoded-access-tokens/</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>using self-encoded tokens if you‚Äôve already solved the distributed database
problem will only introduce new issues, as invalidating self-encoded tokens
becomes an additional hurdle</p>
<p>&mdash; <a href="https://www.oauth.com/oauth2-servers/access-tokens/self-encoded-access-tokens/">https://www.oauth.com/oauth2-servers/access-tokens/self-encoded-access-tokens/</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>One way to create self-encoded tokens is to create a JSON-serialized
representation of all the data you want to include in the token, and sign the
resulting string with a key known only to your server.</p>
<p>&mdash; <a href="https://www.oauth.com/oauth2-servers/access-tokens/self-encoded-access-tokens/">https://www.oauth.com/oauth2-servers/access-tokens/self-encoded-access-tokens/</a></p>
</blockquote>
<h3 id="5d9fcc89-c31e-43ed-a53f-b548eb688999">bearer token</h3>
<ul>
<li>
<p>External reference: <a href="https://datatracker.ietf.org/doc/html/rfc6750">https://datatracker.ietf.org/doc/html/rfc6750</a></p>
</li>
<li>
<p>External reference: <a href="https://oauth.net/2/bearer-tokens/">https://oauth.net/2/bearer-tokens/</a>
<a href="/braindump/posts/oauth_2_0/">OAuth 2.0</a> Bearer Token Usage</p>
<blockquote>
<p>Bearer Token is an opaque string, not intended to have any meaning to clients
using it. Some servers will issue tokens that are a short string of hexadecimal
characters, while others may use structured tokens such as JSON Web Tokens.</p>
<p>&mdash; <a href="https://oauth.net/2/bearer-tokens/">https://oauth.net/2/bearer-tokens/</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>Bearer Token</p>
<p>A security token with the property that any party in possession of
the token (a &ldquo;bearer&rdquo;) can use the token in any way that any other
party in possession of it can.  Using a bearer token does not
require a bearer to prove possession of cryptographic key material
(proof-of-possession).</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6750">https://datatracker.ietf.org/doc/html/rfc6750</a></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>When sending the access token in the <a href="/braindump/posts/authorization_request_header/">&ldquo;Authorization&rdquo; request header</a>
field defined by HTTP/1.1 [<a href="/braindump/posts/http_1_1/">RFC2617</a>], the client uses the &ldquo;Bearer&rdquo;
authentication scheme to transmit the access token.</p>
<p>For example:</p>
<p>GET /resource HTTP/1.1
Host: server.example.com
Authorization: Bearer mF_9.B5f-4.1JqM</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6750">https://datatracker.ietf.org/doc/html/rfc6750</a></p>
</blockquote>
<h2 id="f86ccef1-e4b1-413f-b78c-8070f4dceafa">oauth 2.0 client</h2>
<ul>
<li>
<p>External reference: <a href="https://datatracker.ietf.org/doc/html/rfc8725#section-2.8">https://datatracker.ietf.org/doc/html/rfc8725#section-2.8</a></p>
<p>This is a <a href="#02c86448-ca36-4995-b93e-fec4967b3b9c">third party</a><sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>.</p>
<blockquote>
<dl>
<dt><a href="/braindump/posts/json_web_tokens/">JWT</a> <a href="#26052c2d-ac4a-4637-9122-704d51585dc8">access token</a></dt>
<dd>An OAuth 2.0 access token encoded in JWT format and
complying with the requirements described in this specification</dd>
</dl>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc9068">https://datatracker.ietf.org/doc/html/rfc9068</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>OAuth 2.0, which stands for ‚ÄúOpen Authorization‚Äù, is a standard designed to allow a website or application to access resources hosted by other web apps on behalf of a user</p>
<p>&mdash; <a href="https://auth0.com/intro-to-iam/what-is-oauth-2/">https://auth0.com/intro-to-iam/what-is-oauth-2/</a></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>OAuth 2.0 is an authorization protocol and NOT an authentication protocol</p>
<p>&mdash; <a href="https://auth0.com/intro-to-iam/what-is-oauth-2/">https://auth0.com/intro-to-iam/what-is-oauth-2/</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>designed primarily as a means of granting access to a set of resources,</p>
<p>&mdash; <a href="https://auth0.com/intro-to-iam/what-is-oauth-2/">https://auth0.com/intro-to-iam/what-is-oauth-2/</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>Access Token is a piece of data that represents the authorization to access resources on behalf of the end-user.</p>
<p>&mdash; <a href="https://auth0.com/intro-to-iam/what-is-oauth-2/">https://auth0.com/intro-to-iam/what-is-oauth-2/</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>OAuth 2.0 doesn‚Äôt define a specific format for Access Tokens. However, in some contexts, the JSON Web Token (JWT) format is often used. This enables token issuers to include data in the token itself.</p>
<p>&mdash; <a href="https://auth0.com/intro-to-iam/what-is-oauth-2/">https://auth0.com/intro-to-iam/what-is-oauth-2/</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>for security reasons, Access Tokens may have an expiration date.</p>
<p>&mdash; <a href="https://auth0.com/intro-to-iam/what-is-oauth-2/">https://auth0.com/intro-to-iam/what-is-oauth-2/</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>Scopes are an important concept in OAuth 2.0. They are used to specify exactly the reason for which access to resources may be granted.</p>
<p>&mdash; <a href="https://auth0.com/intro-to-iam/what-is-oauth-2/">https://auth0.com/intro-to-iam/what-is-oauth-2/</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>for better security, an Authorization Code may be returned, which is then exchanged for an Access Token.¬† In</p>
<p>&mdash; <a href="https://auth0.com/intro-to-iam/what-is-oauth-2/">https://auth0.com/intro-to-iam/what-is-oauth-2/</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>grants are the set of steps a Client has to perform to get resource access authorization</p>
<p>&mdash; <a href="https://auth0.com/intro-to-iam/what-is-oauth-2/">https://auth0.com/intro-to-iam/what-is-oauth-2/</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>There are three main steps to OAuth 2.0:</p>
<ul>
<li>Request authorization from a user to access their data.</li>
<li>Query the user&rsquo;s data using the provided access token.</li>
<li>Refresh expired access tokens with the corresponding refresh token.</li>
</ul>
<p>&mdash; <a href="https://dev.fitbit.com/build/reference/web-api/developer-guide/authorization/">https://dev.fitbit.com/build/reference/web-api/developer-guide/authorization/</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>traditional client-server authentication model, the client
requests an access-restricted resource (protected resource) on the
server by authenticating with the server using the resource owner&rsquo;s
credentials.  In order to provide third-party applications access to
restricted resources, the resource owner shares its credentials with
the third party.</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>Third-party applications gain overly broad access to the resource
owner&rsquo;s protected resources, leaving resource owners without any
ability to restrict duration or access to a limited subset of
resources</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>o  Resource owners cannot revoke access to an individual third party
without revoking access to all third parties, and must do so by
changing the third party&rsquo;s password</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>OAuth addresses these issues by introducing an authorization layer
and separating the role of the client from that of the resource
owner.</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>Instead of using the resource owner&rsquo;s credentials to access protected
resources, the client obtains an access token &ndash; a string denoting a specific
scope, lifetime, and other access attributes.  Access tokens are issued to
third-party clients by an authorization server with the approval of the
resource owner.  The client uses the access token to access the protected
resources hosted by the resource server.</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>For example, an end-user (resource owner) can grant a printing
service (client) access to her protected photos stored at a photo-
sharing service (resource server), without sharing her username and
password with the printing service.  Instead, she authenticates
directly with a server trusted by the photo-sharing service
(authorization server), which issues the printing service delegation-
specific credentials (access token).</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>use of OAuth over any protocol other than HTTP is out of scope.</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>single authorization server may issue access tokens accepted by
multiple resource servers.</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>authorization code is obtained by using an authorization server
as an intermediary between the client and resource owner</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>client
directs the resource owner to an authorization server (via its
user-agent as defined in [RFC2616]), which in turn directs the
resource owner back to the client with the authorization code</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>Because the resource owner
only authenticates with the authorization server, the resource
owner&rsquo;s credentials are never shared with the client.</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>authorization code provides a few important security benefits,
such as the ability to authenticate the client, as well as the
transmission of the access token directly to the client without
passing it through the resource owner&rsquo;s user-agent and potentially
exposing it to others, including the resource owner</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>When issuing an access token during the implicit grant flow, the
authorization server does not authenticate the client.  In some
cases, the client identity can be verified via the redirection URI
used to deliver the access token to the client.  The access token may
be exposed to the resource owner or other applications with access to
the resource owner&rsquo;s user-agent.</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>client credentials (or other forms of client authentication) can
be used as an authorization grant when the authorization scope is
limited to the protected resources under the control of the client,
or to protected resources previously arranged with the authorization
server.</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>when the client is acting on its own behalf (the client is
also the resource owner) or is requesting access to protected
resources based on an authorization previously arranged with the
authorization server.</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>resource owner password credentials grant type is suitable in
cases where the resource owner has a trust relationship with the
client,</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>server should take special care when
enabling this grant type and only allow it when other flows are not
viable.</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>suitable for clients capable of obtaining the
resource owner&rsquo;s credentials (username and password, typically using
an interactive form).</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<h3 id="5a660aaa-dc0c-43dc-8791-8fc47ca3e895">third party client</h3>
<h3 id="28c0dea8-7e16-4a73-8029-d99422f0142f">two kinds of client</h3>
<h4 id="118410f7-3339-4794-8107-b03880897104">public client</h4>
<p>In brief, a public client runs on an environment that the END USER controls.</p>
<p>It cannot keep secret the <a href="#6f4dbac8-544f-4be9-b9ee-8a42353caa90">client secret</a> and therefore cannot do the
<a href="#def201dd-26c7-44f9-8456-ad5d3c631731">authorization code flow</a>. Yet, it can run the <a href="/braindump/posts/oauth_2_1/#b8a57c75-44c9-4f89-a88e-635bcb618246">authorization code grant with
PKCE</a>, because it is like the former, but with a dynamically generated
client secret.</p>
<p>A public client cannot ensure that the client id or client secret are not
re-used by the users of the client. In case of web client, one should rather
use server side communication with the server hosting the web client to
ensure the id of the client.</p>
<h4 id="12b392a5-8463-44e4-b3ef-e61b4c90e47c">confidential</h4>
<p>In brief, a public client runs on an environment that the DEVELOPER controls.</p>
<p>It can keep secret the <a href="#6f4dbac8-544f-4be9-b9ee-8a42353caa90">client secret</a> and then use the <a href="#def201dd-26c7-44f9-8456-ad5d3c631731">authorization
code flow</a> securely.</p>
<h3 id="d961c0b3-9f25-4ba7-91cc-bae3f100d997">client id</h3>
<h3 id="6f4dbac8-544f-4be9-b9ee-8a42353caa90">client secret</h3>
<p>Its purpose is to make sure in the end of the flow that the <a href="#f86ccef1-e4b1-413f-b78c-8070f4dceafa">client</a> is indeed
the expected one. This makes only sense in the case of a <a href="#12b392a5-8463-44e4-b3ef-e61b4c90e47c">confidential</a>
client, because in the case of a <a href="#118410f7-3339-4794-8107-b03880897104">public</a> client, the secret can easily be
read by anyone using the client.</p>
<p>In the case of a <a href="#118410f7-3339-4794-8107-b03880897104">public</a> client, one should rather use <a href="/braindump/posts/oauth_2_1/#b8a57c75-44c9-4f89-a88e-635bcb618246">authorization code grant with PKCE</a>.</p>
<ul>
<li>see,
<ul>
<li><a href="/braindump/posts/oauth_the_good_parts_anders_abel/">OAuth ‚Äì the good Parts - Anders Abel - NDC Oslo 2022 - YouTube</a>,</li>
</ul>
</li>
</ul>
<h4 id="1730c1b2-9716-4fe3-b3b7-a9455174fdc1">do we really need client_secret to get access_token on PKCE flow?</h4>
<ul>
<li>
<p>External reference: <a href="https://stackoverflow.com/questions/63057801/do-we-really-need-client-secret-to-get-access-token-on-pkce-flow">https://stackoverflow.com/questions/63057801/do-we-really-need-client-secret-to-get-access-token-on-pkce-flow</a></p>
<blockquote>
<p>The <a href="#6f4dbac8-544f-4be9-b9ee-8a42353caa90">client secret</a> allows the authorization server (identity provider) to
determine the identity of the client</p>
<p>&mdash; <a href="https://stackoverflow.com/questions/63057801/do-we-really-need-client-secret-to-get-access-token-on-pkce-flow">https://stackoverflow.com/questions/63057801/do-we-really-need-client-secret-to-get-access-token-on-pkce-flow</a></p>
</blockquote>
</li>
</ul>
<h2 id="88493c43-843b-4eb5-9074-57a4aa814ea5"><a href="/braindump/posts/oauth_2_0/">OAuth 2.0</a> <a href="#26052c2d-ac4a-4637-9122-704d51585dc8">access token</a> response</h2>
<blockquote>
<p>authorization server issues an access token and optional refresh
token, and constructs the response by adding the following parameters
to the entity-body of the HTTP response with a 200 (OK) status code:</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<dl>
<dt>access_token</dt>
<dd>REQUIRED.  The access token issued by the authorization server.</dd>
<dt>token_type</dt>
<dd>REQUIRED.  The type of the token issued as described in Section 7.1.
Value is case insensitive.</dd>
<dt>expires_in</dt>
<dd>RECOMMENDED.  The lifetime in seconds of the access token.  For
example, the value &ldquo;3600&rdquo; denotes that the access token will expire in one
hour from the time the response was generated.  If omitted, the authorization
server SHOULD provide the expiration time via other means or document the
default value.</dd>
<dt>refresh_token</dt>
<dd>OPTIONAL.  The refresh token, which can be used to obtain new access
tokens using the same authorization grant as described in Section 6.</dd>
<dt>scope</dt>
<dd>OPTIONAL, if identical to the scope requested by the client; otherwise,
REQUIRED.  The scope of the access token as described by Section 3.3.</dd>
</dl>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>For example:</p>
<p>HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache</p>
<p>{
&ldquo;access_token&rdquo;:&ldquo;2YotnFZFEjr1zCsicMWpAA&rdquo;,
&ldquo;token_type&rdquo;:&ldquo;example&rdquo;,
&ldquo;expires_in&rdquo;:3600,
&ldquo;refresh_token&rdquo;:&ldquo;tGzv3JOkF0XG5Qx2TlKWIA&rdquo;,
&ldquo;example_parameter&rdquo;:&ldquo;example_value&rdquo;
}</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<h2 id="f691f972-8a34-4c8f-919e-f6fe29b9ae45">types of attack</h2>
<h3 id="2d571b96-bc66-47f1-8efb-822acf452823">misuse of access token to impersonate resource owner in implicit flow</h3>
<ul>
<li>External reference: <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-10.16">https://datatracker.ietf.org/doc/html/rfc6749#section-10.16</a></li>
</ul>
<h2 id="notes-linking-here">Notes linking here</h2>
<ul>
<li><a href="/braindump/posts/authorization_request_header/">&ldquo;Authorization&rdquo; request header</a></li>
<li><a href="/braindump/posts/backend_for_frontend/#a-cookie-to-deal-with-session-create-fewer-attack-surface">a cookie to deal with session create fewer attack surface</a></li>
<li><a href="/braindump/posts/protect_your_apis_with_oauth/#cbafd43b-c5f7-45d5-af1f-96f344a6798d">a public client CANNOT securely save a client secret</a></li>
<li><a href="/braindump/posts/access_token_validation_in_openid_connect/">Access Token Validation in openid connect</a></li>
<li><a href="https://konubinix.eu/blog/posts/what_should_i_put_into_those_scopes_and_access_tokens_claims/?title=according_to_oauth#according-to-oauth">According to OAuth</a> (blog)</li>
<li><a href="/braindump/posts/api_key_vs_client_id_secret/">API key vs client id/secret</a></li>
<li><a href="https://konubinix.eu/blog/posts/make_sense_of_keycloak_openid_connect_oauth_2_0_jwt_jws/?title=as_an_openid_provider#as-an-openid-provider">As an openid provider</a> (blog)</li>
<li><a href="/braindump/posts/audience_claim/">audience claim</a></li>
<li><a href="/braindump/posts/authentication_with_oauth_2_0/">Authentication with OAuth 2.0</a></li>
<li><a href="/braindump/posts/oauth_2_1/#b8a57c75-44c9-4f89-a88e-635bcb618246">authorization code grant with PKCE</a></li>
<li><a href="/braindump/posts/authorization_server_redirection_and_user_experience/">authorization server redirection and user experience</a></li>
<li><a href="/braindump/posts/backend_for_frontend/">backend for frontend</a></li>
<li><a href="/braindump/posts/claims_based_identity/">claims-based identity</a></li>
<li><a href="https://konubinix.eu/blog/posts/clk_k8s_and_earthly_in_a_local_dev_env/?title=clk_k8s_and_earthly_in_a_local_dev_env#">clk k8s and earthly in a local dev env</a> (blog)</li>
<li><a href="https://konubinix.eu/blog/posts/clk_k8s_accessing_the_host_from_the_pod_on_linux_and_mac/?title=clk_k8s_accessing_the_host_from_the_pod_on_linux_and_mac#">clk k8s: accessing the host from the pod on linux and mac</a> (blog)</li>
<li><a href="/braindump/posts/ways_to_authenticate/#embedded-password-in-each-client">embedded password in each client</a></li>
<li><a href="/braindump/posts/everything_you_ever_wanted_to_know_about_oauth_and_oidc/">Everything You Ever Wanted to Know About OAuth and OIDC</a></li>
<li><a href="/braindump/posts/openid_connect/#cc97bfc8-ee07-4dca-921c-2b6fac57f93b">Footnotes</a></li>
<li><a href="/braindump/posts/forget_about_oauth_2_0_here_comes_oauth_2_1_philippe_de_ryck_ndc_oslo_2022/">Forget about OAuth 2.0. Here comes OAuth 2.1 - Philippe De Ryck - NDC Oslo 2022</a></li>
<li><a href="/braindump/posts/oauth_2_1/#1ea6bc5b-42cc-4f26-b8ff-199269676e6f">from 5 grant flow to 2</a></li>
<li><a href="/braindump/posts/goa/">goa</a></li>
<li><a href="/braindump/posts/google_account_security_to_change_the_third_party_scope_consent_screen/">google account security to change the third party scope consent screen</a></li>
<li><a href="/braindump/posts/oauth_2_0_for_client_side_web_applications_authorization_google_developers_spa/#c70912c6-bea8-4770-9753-9874b6aa0144">google api endpoint /auth OAuth 2.0</a></li>
<li><a href="/braindump/posts/google_oauth2_testing_refresh_token_7_days/">google oauth2 testing refresh token == 7 days</a></li>
<li><a href="/braindump/posts/grant_negotiation_and_access_protocol/">grant negotiation and access protocol</a></li>
<li><a href="https://konubinix.eu/blog/posts/how_do_i_create_an_oauth_2_0_oidc_resource_server/?title=how_do_i_create_an_oauth_2_0_oidc_resource_server#">how do I create an OAuth 2.0/OIDC resource server?</a> (blog)</li>
<li><a href="/braindump/posts/how_to_deal_with_permissions_in_oauth2/">how to deal with permissions in OAuth2?</a></li>
<li><a href="/braindump/posts/how_to_hack_oauth/">How to Hack OAuth</a></li>
<li><a href="/braindump/posts/ory/#hydra-the-id-c177c189-8e25-4b44-abd0-e26e6847326d-oidc-layer">hydra: the OIDC layer</a></li>
<li><a href="/braindump/posts/id_tokens_vs_access_tokens/">ID Tokens vs Access Tokens</a></li>
<li><a href="/braindump/posts/identity_provider/">Identity Provider</a></li>
<li><a href="/braindump/posts/implementing_saga_with_access_token/">implementing saga with access token</a></li>
<li><a href="/braindump/posts/introduction_to_oauth_and_openid_connect/">Introduction to OAuth and OpenID Connect</a></li>
<li><a href="/braindump/posts/is_the_bearer_token_opaque/">is the bearer token opaque?</a></li>
<li><a href="/braindump/posts/oauth_2_1/#32f9730f-49e2-4b53-8cf6-fb75d0bce573">it mostly removed stuffs from OAuth 2.0</a></li>
<li><a href="/braindump/posts/json_web_token_best_current_practices/">JSON Web Token Best Current Practices</a></li>
<li><a href="/braindump/posts/json_web_tokens/">JSON web tokens</a></li>
<li><a href="/braindump/posts/jwt_access_tokens_profile_for_oauth_2_0/">JWT Access Tokens profile for OAuth 2.0</a></li>
<li><a href="/braindump/posts/jwt_access_tokens_profile_for_oauth_2_0/">JWT Access Tokens profile for OAuth 2.0</a></li>
<li><a href="/braindump/posts/protect_your_apis_with_oauth/#091fa3a1-34d1-41fd-a955-bda0e8924acc">JWT Access Tokens profile for OAuth 2.0 may be different from implementations</a></li>
<li><a href="https://konubinix.eu/blog/posts/make_sense_of_keycloak_openid_connect_oauth_2_0_jwt_jws/?title=make_sense_of_keycloak_openid_connect_oauth_2_0_jwt_jws#">make sense of keycloak, openid connect, oauth 2.0, jwt, jws</a> (blog)</li>
<li><a href="/braindump/posts/making_sense_of_github_oidc_flow/">making sense of github OIDC flow</a></li>
<li><a href="/braindump/posts/metaphor_of_the_hotel/">metaphor of the hotel</a></li>
<li><a href="/braindump/posts/authentication_vs_identification_vs_authorization/#d79c6fa0-4323-46b0-8fae-1322013e418a">misconceptions</a></li>
<li><a href="/braindump/posts/openid_connect/#8213f6f0-7069-4443-b43b-ff5207a4b650">misconcetions</a></li>
<li><a href="https://konubinix.eu/blog/posts/what_should_i_put_into_those_scopes_and_access_tokens_claims/?title=my_opinion#my-opinion">My opinion</a> (blog)</li>
<li><a href="/braindump/posts/oauth_2/">OAuth 2</a></li>
<li><a href="/braindump/posts/oauth_2_with_single_page_apps/">OAuth 2 with Single-Page Apps</a></li>
<li><a href="/braindump/posts/oauth_2_0_authorization_server_metadata/">OAuth 2.0 Authorization Server Metadata</a></li>
<li><a href="/braindump/posts/oauth_2_0_for_browser_based_apps/">OAuth 2.0 for Browser-Based Apps</a></li>
<li><a href="/braindump/posts/oauth_2_0_playground/">OAuth 2.0 Playground</a></li>
<li><a href="/braindump/posts/oauth_2_0_security_best_current_practice/">OAuth 2.0 Security Best Current Practice</a></li>
<li><a href="/braindump/posts/oauth_2_0_threat_model_and_security_considerations/">OAuth 2.0 Threat Model and Security Considerations</a></li>
<li><a href="https://konubinix.eu/blog/posts/make_sense_of_keycloak_openid_connect_oauth_2_0_jwt_jws/?title=oauth_2_0_to_define_the_authentication_flow#oauth-2-dot-0-to-define-the-authentication-flow">Oauth 2.0 to define the authentication flow</a> (blog)</li>
<li><a href="/braindump/posts/oauth_2_0_token_exchange/">OAuth 2.0 Token Exchange</a></li>
<li><a href="/braindump/posts/oauth_2_0_token_introspection/">OAuth 2.0 Token Introspection</a></li>
<li><a href="/braindump/posts/oauth_2_1/">OAuth 2.1</a></li>
<li><a href="/braindump/posts/oauth_and_openid_connect_in_plain_english/">OAuth and OpenID Connect in Plain English</a></li>
<li><a href="/braindump/posts/oauth_in_five_minutes/">OAuth in Five Minutes</a></li>
<li><a href="/braindump/posts/oauth_it_s_complicated/">OAuth It s complicated</a></li>
<li><a href="/braindump/posts/oauth_security_best_practices/">oauth security best practices</a></li>
<li><a href="/braindump/posts/oauth_sketch_notes_q_a_pkce_scopes_security_passwordless/">OAuth Sketch Notes Q&amp;A - PKCE, Scopes, Security, Passwordless</a></li>
<li><a href="/braindump/posts/oauth_the_good_parts_dominick_baier/">OAuth the good Parts Dominick Baier</a></li>
<li><a href="/braindump/posts/oauth_the_good_parts_anders_abel/">OAuth ‚Äì the good Parts - Anders Abel</a></li>
<li><a href="/braindump/posts/oauth2_demo_with_a_sidecar/">OAuth2 Demo with a Sidecar</a></li>
<li><a href="/braindump/posts/oauth2_explained_with_cute_shapes/">OAuth2 explained with cute shapes</a></li>
<li><a href="/braindump/posts/oidc_vs_oauth2/">OIDC vs OAuth2</a></li>
<li><a href="/braindump/posts/openid_connect/">OpenID Connect</a></li>
<li><a href="/braindump/posts/openid_connect_is_it_fine_to_use_id_token_as_access_token_stack_overflow/">OpenID Connect : Is it fine to use id_token as access_token? - Stack Overflow</a></li>
<li><a href="/braindump/posts/openid_connect/#649456a8-989a-4e4c-808c-a38107d75e5b">OpenID Connect Provider</a></li>
<li><a href="/braindump/posts/playing_with_auth0_for_the_first_time/">playing with auth0 for the first time</a></li>
<li><a href="/braindump/posts/playing_with_google_oidc/">playing with google OIDC</a></li>
<li><a href="/braindump/posts/protect_your_apis_with_oauth/">Protect Your APIs with OAuth</a></li>
<li><a href="/braindump/posts/protecting_your_apis_with_oauth/">Protecting Your APIs with OAuth</a></li>
<li><a href="/braindump/posts/relying_party/">relying party</a></li>
<li><a href="/braindump/posts/resource_indicators_for_oauth_2_0/">Resource Indicators for OAuth 2.0</a></li>
<li><a href="/braindump/posts/resource_owner/">resource owner</a></li>
<li><a href="/braindump/posts/resource_server_does_not_need_to_know_about_the_resource_owner/">resource server does not need to know about the resource owner</a></li>
<li><a href="/braindump/posts/rfc_7636_proof_key_for_code_exchange_by_oauth_public_clients/">RFC 7636: Proof Key for Code Exchange by OAuth Public Clients</a></li>
<li><a href="/braindump/posts/rfc_8705_oauth_2_0_mutual_tls_client_authentication_and_certificate_bound_access_tokens/">RFC 8705 - OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens</a></li>
<li><a href="/braindump/posts/rfc_8783_distributed_denial_of_service_open_threat_signaling_dots_data_channel_specification/">RFC 8783: Distributed Denial-of-Service Open Threat Signaling (DOTS) Data Channel Specification</a></li>
<li><a href="/braindump/posts/openid_connect/#b1a4158b-f5fb-43c8-883a-93572fbc44f7">scopes</a></li>
<li><a href="/braindump/posts/securing_applications_and_services_guide/">Securing Applications and Services Guide</a></li>
<li><a href="/braindump/posts/securing_your_apis_with_oauth_2_0/">Securing Your APIs with OAuth 2.0</a></li>
<li><a href="/braindump/posts/securing_spas_and_blazor_applications_using_the_bff_backend_for_frontend_pattern_dominick_baier/">Securing-SPAs-and-Blazor-Applications-using-the-BFF-Backend-for-Frontend-Pattern-Dominick-Baier</a></li>
<li><a href="/braindump/posts/several_instances_of_client/">several instances of client</a></li>
<li><a href="https://konubinix.eu/blog/posts/should_i_say_jwt_or_jwt_token_or_jws_token_or/?title=should_i_say_jwt_or_jwt_token_or_jws_token_or#">should I say JWT or JWT token, or JWS token or&hellip;?</a> (blog)</li>
<li><a href="/braindump/posts/single_sign_on/">single sign-on</a></li>
<li><a href="/braindump/posts/protect_your_apis_with_oauth/#82c649c7-2d2c-4e7b-aad5-f81db6e22d81">the user consent screen is not compulsory</a></li>
<li><a href="/braindump/posts/three_worlds_analogy/">three worlds analogy</a></li>
<li><a href="/braindump/posts/trying_authenticating_to_keycloak_using_google_as_identity_provider/">trying authenticating to keycloak using google as Identity Provider</a></li>
<li><a href="/braindump/posts/oauth_2_1/#a5e442f5-162b-4d81-a933-a7d999f11681">use an exhaustive list of redirect uri in exact match</a></li>
<li><a href="/braindump/posts/use_differents_kinds_of_scope/">use differents kinds of scope</a></li>
<li><a href="/braindump/posts/openid_connect/#ae9e20b5-1834-47cf-9715-225f30fceaab">userinfo endpoint</a></li>
<li><a href="https://konubinix.eu/blog/posts/make_sense_of_keycloak_openid_connect_oauth_2_0_jwt_jws/?title=using_a_bearer_token_encoded_in_jwt_format#using-a-bearer-token-encoded-in-jwt-format">using a bearer token encoded in JWT format?</a> (blog)</li>
<li><a href="/braindump/posts/backend_for_frontend/#using-a-service-worker--web-worker--instead">using a service worker (web worker) instead</a></li>
<li><a href="/braindump/posts/using_google_as_identity_provider_is_not_doing_sso/">using google as identity provider is not doing SSO</a></li>
<li><a href="/braindump/posts/using_id_token_as_access_token/">using id token as access token?</a></li>
<li><a href="/braindump/posts/github_container_registry/#c25a3a83-111b-499a-8fbc-7ea1b4bb7f29">using personal access token (PAT)</a></li>
<li><a href="/braindump/posts/oauth_2_1/#2bd9112e-b6f2-450a-a68d-5d3ea5ce41f6">using pkce does not prevent from using the client secret</a></li>
<li><a href="https://konubinix.eu/blog/posts/what_should_i_put_into_those_scopes_and_access_tokens_claims/?title=what_should_i_put_into_those_scopes_and_access_tokens_claims#">what should I put into those scopes and access tokens claims?</a> (blog)</li>
<li><a href="https://konubinix.eu/blog/posts/what_should_i_put_into_those_scopes_and_access_tokens_claims/?title=what_should_i_put_into_those_scopes_and_access_tokens_claims#">what should I put into those scopes and access tokens claims?</a> (blog)</li>
<li><a href="/braindump/posts/oauth_2_1/#b1648b84-77ee-4430-8767-1cec20e9a94c">What&rsquo;s new with OAuth2.1 with Aaron Parecki</a></li>
<li><a href="/braindump/posts/which_oauth_2_0_flow_should_i_use/">Which OAuth 2.0 Flow Should I Use?</a></li>
</ul>
<h2 id="permalink"><a href="https://konubinix.eu/braindump/c9fbfeed-e3fa-4a74-bdd7-65365e4be131?title=oauth_2_0">Permalink</a></h2>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<blockquote>
<p><a href="/braindump/posts/json_web_tokens/">JWT</a>s can be used as OAuth 2.0 Bearer Tokens to encode all relevant parts of an
access token into the access token itself instead of having to store them in a
database</p>
<p>&mdash; <a href="https://oauth.net/2/jwt/">https://oauth.net/2/jwt/</a></p>
</blockquote>
&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></li>
<li id="fn:2">
<blockquote>
<p>Before directing the resource owner back to the client with the
authorization code, the authorization server authenticates the
resource owner and obtains authorization.  Because the resource owner
only authenticates with the authorization server, the resource
owner&rsquo;s credentials are never shared with the client.</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
<!--more-->
&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></li>
<li id="fn:3">
<blockquote>
<p>OAuth 2.0 authorization framework enables a third-party
application to obtain limited access to an HTTP service, either on
behalf of a resource owner by orchestrating an approval interaction
between the resource owner and the HTTP service, or by allowing the
third-party application to obtain access on its own behalf.</p>
<p>&mdash; <a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a></p>
</blockquote>
&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></li>
</ol>
</div>
      </div>
	  <aside class="date"><time>Last updated: 02 Jan 2025</time></aside>
	  <aside class="date"><time>Published&nbsp;&nbsp;&nbsp;: 17 Dec 2020</time></aside>
    </div>
  </div>
</div>

<script src="/braindump/js/URI.js" type="text/javascript"></script>

<script src="/braindump/js/page.js" type="text/javascript"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>
