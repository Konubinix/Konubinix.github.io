<!DOCTYPE html>
<html><title>sgx documentation</title>


<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="google-site-verification" content="bLmaFyyXugiCqSup-eIIIx0B4CngtdF_svyMMKQbS5E" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=10, minimum-scale=0.5, user-scalable=yes">
<meta name="apple-mobile-web-app-capable" content="yes" />
<script src="https://hypothes.is/embed.js" async></script>


<link rel="stylesheet" href="/braindump/css/main.min.56b43bcbc759a196f9dd525bee62bdec45a29ba95902bbab74a4f7ad2ea3e8cb.css"/>

<link rel="stylesheet" href="/braindump/css/links.min.4bf1990b213fb76d2a66153dc6ef9a57d49f536c6baf6e7f19a7948470a38141.css"/>

<link rel="stylesheet" href="/braindump/css/konubinix.min.cf2d0f36945178c647979ee68f1830892e06aa3d481d8913728b5c7462b97f6e.css"/>

<link rel="stylesheet" href="/ipfs/QmQFVQS89fv1XUNFcjwCKDePzckuT9kpuAVNYUwNdEfYcv/css/all.css"/>
<link rel="shortcut icon" href="/ipfs/QmVFwYV7YRZLKU3ybN1hW4jqfyZGPLKJwd8toN2wHz5UAD?a.png" type="image/x-icon" />

<body><header>
  <div>
	<a href="/braindump//"><h5 class="site-title">Konubinix&#39; opinionated web of thoughts</h5></a>
  </div>
  <span>
	<a href="/blog/"><i class="icon fas fa-blog"></i></a>
	<a href="/braindump/posts/"><i class="icon fas fa-brain"></i></a>
    <a href="mailto:konubinixweb@gmail.com"><i class="icon fas fa-envelope-square"></i></a>
    <a href="https://github.com/konubinix"><i class="icon fab fa-github-square"></i></a>
    <a href="https://linkedin.com/in/samuel-loury-61259040"><i class="icon fab fa-linkedin"></i></a>
	<a href="/braindump/graph.html"><i class="icon fas fa-project-diagram"></i></a>
	<a href="/braindump/index.xml"><i class="icon fas fa-rss-square"></i></a>
	<a href="/braindump/tags/"><i class="icon fa fa-tag"></i></a>
	<a href="/braindump/braindump_search"><i class="icon fa fa-search"></i></a>
  </span>
</header>

<div class="grid-container">
  <div class="grid">
    <div class="page" data-level="1">
      <div class="content">
		<p class="lead">
        <h1>Sgx Documentation</h1>
		<span class="badge badge-pill badge-warning"><a href="/braindump/tags/fleeting/">Fleeting</a></span></p>
        <div class="ox-hugo-toc toc">
<div class="heading">Table des matières</div>
<ul>
<li><a href="#4d6a187d-7331-4640-bfbc-17fd5e698f25">enclave measurement</a></li>
<li><a href="#b0ece6fb-7130-463d-a002-41186477bce1">Annotations</a>
<ul>
<li><a href="#c57f2c89-822f-42ab-9e8f-a24945fd400a">Introduction</a></li>
<li><a href="#86b90c95-feb7-4c3d-941f-533b530067e6">Enclave Programming Model</a>
<ul>
<li><a href="#216d19b6-b2e3-411e-8188-139cbec9e8ab">Enclave File Format</a></li>
</ul>
</li>
<li><a href="#c6ec85d1-a0a0-482a-bd37-8f930a674e5d">Data exchange in and out of the enclave</a></li>
<li><a href="#51da642a-c227-4992-be82-ab336a314972">Enclave Signature Structure</a></li>
<li><a href="#e015fd6f-35c5-4704-b0ce-99838b80b02f">The attestation process</a>
<ul>
<li><a href="#0db595c9-980f-46b3-99ff-87c348e9bd10">Remote (Inter-Platform) Attestation</a></li>
</ul>
</li>
<li><a href="#438e54d6-3d5a-4d6b-82f9-0b5a4807384a">Secret Provisioning</a></li>
<li><a href="#ec9d125f-7dd1-4fd0-888d-f3b940cbb02a">Sealing</a></li>
<li><a href="#b1868be5-73f8-49ae-afbf-9e017b94808f">Processor Features</a></li>
<li><a href="#459b2b1c-3c51-4eda-aea9-35522dd265c2">Programming for Performance</a>
<ul>
<li><a href="#3efcf273-cb17-4f1b-a0e9-e48ad230f390">Creation</a></li>
<li><a href="#bb2b2e69-274d-4873-b14d-a34d25bf7826">Transitions</a></li>
<li><a href="#db811a16-58cb-4517-af54-945887b79500">Memory access</a></li>
</ul>
</li>
<li><a href="#d5b04918-9910-4bc4-9771-35c455813659">Defense In-depth Mechanisms</a></li>
<li><a href="#ccf6e829-6c45-4ed8-96c8-7d7b39e666a5">Power Management</a></li>
<li><a href="#425d4b79-de26-457c-a995-f85f18910542">Use of Large Addresses for 32-bit Enclaves</a></li>
<li><a href="#0c9e9dfd-5240-4aa2-8a91-f04f7c129fb8">Threading Topics</a></li>
<li><a href="#0521c454-0520-4185-86a0-82187571f796">Protection from Side-Channel Attacks</a></li>
</ul>
</li>
<li><a href="#notes-linking-here">Notes linking here</a></li>
<li><a href="#bibliography">Bibliography</a></li>
<li><a href="#permalink">Permalink</a></li>
</ul>
</div>
<!--endtoc-->
<ul>
<li>External reference: @1ed9f3ea-721f-4e67-965c-a0ff16fc16fe</li>
</ul>
<p><a href="/braindump/posts/intel_sgx/">sgx</a> documentation</p>
<h2 id="4d6a187d-7331-4640-bfbc-17fd5e698f25">enclave measurement</h2>
<p>enclave measurement</p>
<h2 id="b0ece6fb-7130-463d-a002-41186477bce1">Annotations</h2>
<h3 id="c57f2c89-822f-42ab-9e8f-a24945fd400a">Introduction</h3>
<p>The document claims to tell <code>how to develop robust application enclaves</code>.</p>
<figure><img src="https://konubinix.eu/ipfs/bafkreigsp5zgys4kzarvli7lkem5dpm4xmncgqkrmfllngb7atqfybvhnq?filename=a.png">
</figure>

<p>It defines the executing parts as</p>
<blockquote>
<ul>
<li>Untrusted Run-Time System (uRTS) – code that executes outside of the Intel SGX enclave environment</li>
<li>Trusted Run-Time System (tRTS) – code that executes within an Intel SGX enclave (also called Trusted Computing Base in the document)</li>
<li>Edge Routines – functions that may run outside the enclave (untrusted edge routines) or inside the enclave (trusted edge routines)</li>
<li>3rd Party Libraries – for the purpose of this document, this is any library that has been tailored to work inside the Intel SGX enclave environment.</li>
<li><a href="/braindump/posts/ecall/">ECall</a> “Enclave Call” a call made into an interface function within the enclave</li>
<li><a href="/braindump/posts/ocall/">OCall</a> “Out Call” a call made from within the enclave to the outside application</li>
<li>The context Thread Context
for a thread running inside the enclave.
<ul>
<li>Thread Control Structure (TCS)</li>
<li>Thread Data/Thread Local Storage – data within the enclave
and specific to the thread</li>
<li>State Save Area (SSA) – a data buffer which
holds register state when an enclave must
exit due to an interrupt or exception</li>
<li>Stack – a stack located within the enclave</li>
</ul>
</li>
</ul>
</blockquote>
<p>But it also defines or implicitly references :</p>
<ul>
<li>The SGX Application is the whole program</li>
<li>The Enclave <a href="/braindump/posts/trusted_computing_base/">Trusted Computing Base</a> (TCB), or simply enclave is the trusted
part of the SGX Application. It is the same as the tRTS.</li>
<li>Untrusted Component, or Enclave Application is the part of the SGX Application that is not trusted.</li>
<li>Enclave Page Cache (EPC), the memory location of the enclave</li>
</ul>
<h3 id="86b90c95-feb7-4c3d-941f-533b530067e6">Enclave Programming Model</h3>
<p>An enclave &ldquo;can be developed using standard tools and development
environments&rdquo;, but &ldquo;enclave writers must also be aware of the differences in
how Intel SGX software is designed, developed and debugged to create robust
enclave&rdquo;</p>
<p>Also, &ldquo;an enclave is a monolithic software entity that reduces the Trusted
Computing Base (TCB) for an application to a trusted runtime system, ISV code
and 3rd party trusted libraries&rdquo;.</p>
<h4 id="216d19b6-b2e3-411e-8188-139cbec9e8ab">Enclave File Format</h4>
<p>It is &ldquo;a regular DLL, Dynamic Library, or Shared Object file typically
contains code and data sections corresponding to the functions and/or
methods as well as the variables and/or objects implemented in the shared
library&rdquo;</p>
<p>&ldquo;The code in an enclave is no different than code that exists as part of a
regular application&rdquo;.</p>
<p>&ldquo;enclave code is loaded in a special way such that once the enclave has been
initialized, privileged code and the rest of the untrusted application
cannot directly read data that resides in the protected environment&rdquo;</p>
<p>From the point of view of general programming, the enclave programming looks
indeed like normal programming.</p>
<p>It is stressed out that the main &ldquo;it may be possible to move the majority of
application code into an enclave, in most cases this would not be
desirable&rdquo;.</p>
<p>One should make sure to run a code as minimal as possible into the enclave
to reduce risks and take much time thinking of the boundaries between the
trusted and the untrusted part of the application.</p>
<h3 id="c6ec85d1-a0a0-482a-bd37-8f930a674e5d">Data exchange in and out of the enclave</h3>
<p>One must make extra care of the data going in and out of the enclave, meaning
in the ECall and the OCall.</p>
<p>For instance, &ldquo;pointers to C data structures are reasonable, but pointers to
C++ objects are not&rdquo; and &ldquo;the enclave must ensure the data cannot be modified
after it is checked&rdquo;</p>
<blockquote>
<p>An enclave must be designed in such a way that it prevents leaking
<a href="/braindump/posts/side_channel_attack/">side-channel</a> information that would allow an attacker, who is looking at the
untrusted functions called from an enclave, to gain insight into enclave
secrets</p>
<p>[<a href="#citeproc_bib_item_1">1</a>]</p>
</blockquote>
<p>In particular, &ldquo;Nested ECalls (ECalls during OCalls)&rdquo; must not make any
assumption whether they will be called back or not.</p>
<p>Also, &ldquo;Third Party Libraries&rdquo; must follow the same practice.</p>
<h3 id="51da642a-c227-4992-be82-ab336a314972">Enclave Signature Structure</h3>
<p>For the enclave to be useful, it must prove it is whatever it claims it is.</p>
<blockquote>
<p>Establishing trust in software involved three main activities: Measurement, Attestation and Sealing</p>
<ol>
<li>Measurement: As an enclave is instantiated in a trusted environment, an
accurate and protected recording of its identity is taken.</li>
<li>Attestation: Demonstrating to other entities that a particular envir-
onment is instantiated in the correct manner.</li>
<li>Sealing: Enabling data belonging to the trusted environment to be bound
to it so that it can be restored only when the trusted environment is
restored.</li>
</ol>
</blockquote>
<p>The &ldquo;enclaves include a self-signed certificate from the enclave author, also
known as the Enclave Signature Structure (SIGSTRUCT)&rdquo;. This structure
&ldquo;contains information that allows the Intel® SGX architecture to detect
whether any portion of the enclave file has been tampered with&rdquo;. Also, it
&ldquo;identifies the enclave author&rdquo;.</p>
<blockquote>
<p><a href="#4d6a187d-7331-4640-bfbc-17fd5e698f25">Enclave Measurement</a> [&hellip;] a single 256-bit hash that identifies the code
and initial data to be placed inside the enclave, the expected order and
position in which they are to be placed, and the security properties of those
pages. A change in any of these variables will result in a different
measurement. When the enclave code/data pages are placed inside the <a href="/braindump/posts/enclave_page_cache/">EPC</a>, the
CPU calculates the enclave measurement and stores this value in the MRENCLAVE
register. Then the CPU compares the content of <a href="/braindump/posts/mrenclave/">MRENCLAVE</a> against the enclave
measurement value in SIGSTRUCT. Only if they match with each other, the CPU
will allow the enclave to be initialized.</p>
<p>[<a href="#citeproc_bib_item_1">1</a>]</p>
</blockquote>
<p>&ldquo;After an enclave is successfully initialized, the CPU records a hash of the enclave author’s public key in the MRSIGNER register&rdquo;.</p>
<p>This means that not only the processors ensures that the MRENCLAVE is a value
unique to the enclave source code and way of loading, but also the valid key
that signed the enclave is accessible at MRSIGNER.</p>
<p>Also, the enclave should provide a &ldquo;Security Version Number of the Enclave
(ISVSVN) – The enclave author assigns a Security Version Number (SVN) to each
version of an enclave. The SVN reflects the level of the security property of
the enclave, and should monotonically increase with improvements of the
security property. After an enclave is successfully initialized, the CPU
records the SVN, which can be used during attestation. Different versions of
an enclave with the same security property should be assigned with the same
SVN. For example, a new version of an enclave with non security related bug
fixes should have the same SVN as the older version&rdquo;.</p>
<p>To do all that &ldquo;The SDK includes a tool for signing enclaves, called
sgx_sign, that takes an enclave file and adds the enclave signature structure
as required by the Intel® SGX architecture. This tool supports single-step
test signing using a test sign- ing private key configured on the local
system, and two-step release signing that involves a signing
facility/platform, where the release signing private key is
protected. sgx_sign can also generate whitelisting materials from a signed
enclave file.&rdquo;</p>
<p>It is stressed out that &ldquo;the ISV must maintain the development environment
free from malware and other potential threads at all times. If the
development platform is ever com- promised, you cannot continue using the
Intel SGX support software since it could be used to compromise the integrity
of the enclaves built on that platform.&rdquo;</p>
<h3 id="e015fd6f-35c5-4704-b0ce-99838b80b02f">The attestation process</h3>
<p>&ldquo;Attestation is the process of demonstrating that a piece of software has
been established on a platform. In the case of Intel SGX, it is the mechanism
by which a third entity establishes that a software entity is running on an
Intel SGX enabled platform protected within an enclave prior to provisioning
that software with secrets and protected data.&rdquo;</p>
<p>It describes local and remote attestation processes. For I am more interested
in remote attestation, I will only focus on that.</p>
<h4 id="0db595c9-980f-46b3-99ff-87c348e9bd10">Remote (Inter-Platform) Attestation</h4>
<p>In order to assert the validity of an enclave, intel provides a separate
enclave, called the quoting enclave. It &ldquo;verifies the reports that have been
created to its MRENCLAVE measurement value and then converts and signs them
using a device specific asymmetric key, the Intel EPID key. The output of
this process is called a quote.&rdquo;</p>
<p>The device specific asymmetric key (EPID key), is &ldquo;a group signature scheme,
which allows platforms to cryptographically sign objects while at the same
time preserving the signer’s privacy.&rdquo;</p>
<p>That way, the application can generate an EPID signed report with the
enclave signature structure (containing the Author public key hash and the
enclave hash). This report can then be used to validate the claim that the
enclave is really what is pretends to be, provided we trust the EPID
mechanism and the robustness of the enclave report creation.</p>
<p>Then an example of remote attestation process is given.</p>
<figure><img src="https://konubinix.eu/ipfs/bafkreifxg3yyxvbxzq2hvaw4ktvg3z23hhg6jcup2mxwdivuwunkx6y5bu?filename=a.png">
</figure>

<p>Basically, it looks like a classical key sharing scheme, where :</p>
<ol>
<li>the enclave provides
<ol>
<li>the enclave report, signed with <a href="/braindump/posts/intel_enhanced_privacy_id/">EPID</a> allowing the enclave user to authenticate the enclave,</li>
<li>the public key of a temporary key pair whose private part will never get out of the enclave</li>
</ol>
</li>
<li>the user then sends to the enclave, encrypted with the temporary key, a
session symmetric key, to be used in further communication</li>
</ol>
<p>To authenticate the user of the enclave, it is suggested to put a
certificate root inside the code of the enclave, so that the enclave can
first authenticate the user prior to communicating anything with them. The
enclave user could sign the session symmetric key, so that the enclave would
be able to make sure the symmetric key is actually coming from this user.</p>
<p>An important note is that &ldquo;two running instances of an enclave cannot be
distinguished by the automatically generated data in their REPORT’s
alone&rdquo;. A nonce is generally put in the enclave ECall, to allow separating
communications with two running instances.</p>
<h3 id="438e54d6-3d5a-4d6b-82f9-0b5a4807384a">Secret Provisioning</h3>
<p>When dealing with a secret, &ldquo;the enclave may choose to store the secret in
non volatile storage using the sealing techniques&rdquo;.</p>
<p>Indeed, &ldquo;enclave secrets may be safely stored outside the enclave boundary
after such secrets are properly sealed.&rdquo;</p>
<p>But beware that &ldquo;data provisioned to a debug enclave is not secret&rdquo;.</p>
<p>In order to avoid leaking the secret, it is mandatory to &ldquo;use the memset_s()
function to clear any variable that contained secret data&rdquo;, to avoid data
padding during allocation from containing the secret. Also, &ldquo;the use of this
function guarantees that the compiler will not optimize away the write to
memory intended by this function call and thus ensuring the secret data is
cleared. Using memset_s() is especially important when secret data is stored
in a dynamically allocated buffer. After such a buffer is freed it could be
reallocated and its previous contents, if they are not erased, may be leaked
outside the enclave.&rdquo;</p>
<p>Also, the document advises &ldquo;that secrets are cleared after use&rdquo; to diminish
the risk of secret leakage.</p>
<h3 id="ec9d125f-7dd1-4fd0-888d-f3b940cbb02a">Sealing</h3>
<p>&ldquo;A mechanism is in place which allows enclave software to retrieve a key
unique to that enclave. This key can only be generated by that enclave on
that particular platform&rdquo;. This allows the enclave to store the secret
outside the enclave.</p>
<p>There are two &ldquo;Software Sealing Policies&rdquo;: &ldquo;Seal to the Current Enclave (Enclave Measurement)&rdquo; or &ldquo;Seal to the Enclave
Author&rdquo;.</p>
<p>&ldquo;Enclave writers should be aware that even though two running instances of
the same enclave can be distinguished at the time they attest, there is no
Intel® SGX mechanism to prevent one enclave instance from having access to
the sealed data of another enclave when both enclaves use the EGETKEY
instruction.&rdquo;</p>
<p>&ldquo;In order to provide SEAL key separation between enclave instances, including
those executing in a virtualized environments (e.g. datacenter or cloud),
Intel recommends that enclave writers use the KEYID field of the KEYREQUEST
structure passed into the EGETKEY instruction to pass an enclave instance
specific nonce. This will provide a different key even when the same
enclave is in a different virtual machine.&rdquo;</p>
<p>&ldquo;Migrating a user’s data from one platform to the next now requires careful planning&rdquo;, so that the data is not leaked out.</p>
<ol>
<li>the enclaves must attest one another using the attestation mechanism</li>
<li>they share a key to temporarily encrypt the data during the migration</li>
<li>then the old enclave must
<ol>
<li>decrypt the data,</li>
<li>encrypt it using the temporary key</li>
<li>send it to the other enclave</li>
</ol>
</li>
<li>the other enclave then
<ol>
<li>decrypt, using the temporary key</li>
<li>encrypt, using the seal key</li>
</ol>
</li>
</ol>
<p>&ldquo;We refer to these encrypt and decrypt operations as sealing and unsealing,
respectively as the data is cryptographically sealed to the enclave and
platform&rdquo;.</p>
<h3 id="b1868be5-73f8-49ae-afbf-9e017b94808f">Processor Features</h3>
<p>As indicated earlier, it looks like any program can be run inside an
enclave. Yet, the document indicate a few exceptions.</p>
<blockquote>
<p>The following is a list of hardware instructions which are illegal within an enclave and will generate a #UD fault if executed:</p>
<ol>
<li>Instructions which may VMEXIT if executed inside an enclave. Since it is not permissible for the VMM to update the enclave, they are not allowed.
CPUID, GETSEC, RDPMC, RDTSC, RDTSCP, SGDT, SIDT, SLDT, STR, VMCALL, VMFUNC.</li>
<li>
<ol start="2">
<li>I/O instructions cannot be executed inside an enclave. These instructions could cause faults which cannot be handled by software.
IN, INS/INSB/INSW/INSD, OUT, OUTS/OUTSB/OUTSW/OUTSD.</li>
</ol>
</li>
<li>Instructions that may require a change in privilege levels.
Far call, Far jump, Far ret, INT n/INTO, IRET, LDS/LES/LFS/LGS/LSS, MOV to DS/ES/SS/FS/GS, POP DS/ES/SS/FS/GS, SYSCALL, SYSENTER.</li>
</ol>
<p>Functions which gather host system attributes, perform I/O, or require a higher privilege level should be performed outside an enclave.
The CPUID instruction is also illegal inside the enclave. Thus software that retrieves CPUID information must do so outside the enclave.</p>
</blockquote>
<p>It is indicated that &ldquo;the ISV must write a custom exception handler to catch
the #UD fault&rdquo; to allow the correct behavior in case such exceptions occur,
yet it must be remembered that &ldquo;OCalls are not permitted in exception
handlers&rdquo;.</p>
<h3 id="459b2b1c-3c51-4eda-aea9-35522dd265c2">Programming for Performance</h3>
<p>This part reminds us that &ldquo;SGX architecture does not come for free in terms of
impact of the performance on your application&rdquo;.</p>
<h4 id="3efcf273-cb17-4f1b-a0e9-e48ad230f390">Creation</h4>
<p>Among other things, &ldquo;the time to create an enclave scales directly with the size
of the enclave, because each additional 4KB page that an enclave uses results in
cryptographic processing that occurs for the EADD instruction and cryptographic
processing for the 16 EEXTEND instructions to measure that 4KB page&rdquo;.</p>
<p>The document suggests to &ldquo;consider the following approaches to reduce this impact&rdquo;:</p>
<ul>
<li>&ldquo;Reduce the size of your enclave.&rdquo;</li>
<li>Make use of the &ldquo;Enclave Dynamic Memory Management (EDMM)&rdquo;</li>
<li>or hide the enclave loading time by having the application perform processing that occupies the user’s attention</li>
</ul>
<h4 id="bb2b2e69-274d-4873-b14d-a34d25bf7826">Transitions</h4>
<p>Transition occurs when the code path goes in the enclave and outside of the
enclave, meaning ECall and OCall are transitions.</p>
<blockquote>
<p>Transitions to an enclave and from an enclave resemble a context switch in many ways.
Parameters are marshalled from the untrusted part of the application to the trusted part, and return values are un-marshalled.
In the trusted part, parameters from the untrusted part are un-marshalled and return values for the untrusted part are marshalled.</p>
</blockquote>
<p>This is important, because &ldquo;if an application is passing large parameters
between the two parts of an application, a noticeable overhead can be
experienced&rdquo;.</p>
<p>To palliate this issue, it is suggested to &ldquo;pass a pointer to the data
structure into the enclave instead of the actual data&rdquo;.</p>
<p>Yet, &ldquo;there is a security risk because the Edger8r tool does not verify the
pointer before passing it to the enclave&rdquo;.</p>
<p>In the end, this is not an easy task, because &ldquo;you as the developer must
ensure that you are not exposing secrets in untrusted memory. You must also
implement your own pointer verification if you choose this method.&rdquo;</p>
<h4 id="db811a16-58cb-4517-af54-945887b79500">Memory access</h4>
<p>Another aspect increasing processor time is cache misses.</p>
<p>&ldquo;If your application is experiencing overhead associated with a high number
of cache misses,&rdquo; then &ldquo;Reduce the size of your enclave’s data. Inspect your
data to ensure that only critical elements are in the enclave. Less data
means less encryption/decryption and less data structure checking by the
Intel® SGX memory control/protection mechanism.&rdquo;</p>
<p>Also, &ldquo;Excessive Writing of Pages&rdquo; may reduce performance a lot.</p>
<h3 id="d5b04918-9910-4bc4-9771-35c455813659">Defense In-depth Mechanisms</h3>
<p>In this part, the document suggests a few tricks to increase the security of the enclave.</p>
<p>&ldquo;Enclave writers should set the compiler options such that by default enclaves
are built with standard defense in-depth mechanisms available on a given
platform.&rdquo;</p>
<p>It is reminded that &ldquo;the commonly used compiler options only provide
protection when the buffer meets certain criteria&rdquo;, then the developer must
ensure those criteria are met in the wanted situations.</p>
<p>For example, &ldquo;&ndash;fstack-protector does not provide protection when the size of
the buffer in stack is below certain threshold to avoid significant
performance penalty&rdquo;.</p>
<p>It is recommended to &ldquo;apply more strict checking options&rdquo;, like
&ldquo;&ndash;fstack-protector-all, &ndash;fstack-protector-strong, and
&ndash;fstack-protector-explicit&rdquo;.</p>
<p>Also, code relocation inducing the need to make the code writable, it is
advised &ldquo;for the code to contain no relocations&rdquo;.</p>
<p>It is eventually advised to beware the &ldquo;Unsafe C++11 Attributes&rdquo;, like
&ldquo;noreturn, in particular&rdquo;, that &ldquo;may cause a potential security risk&rdquo;.</p>
<h3 id="ccf6e829-6c45-4ed8-96c8-7d7b39e666a5">Power Management</h3>
<p>&ldquo;SGX architecture does not provide a way of directly messaging the power down
event into the enclave.&rdquo;</p>
<p>Particularly, &ldquo;the operating system does not guarantee that the enclave will
be given enough time to seal all its internal state.&rdquo;</p>
<p>&ldquo;Enclaves that wish to preserve state across power transition events must
periodically seal enclave state data outside the enclave (on disk or the
cloud). On re-instantiation of the application, the enclave is rebuilt from
scratch and the enclave must retrieve its protected state (from disk or the
cloud) inside the enclave.&rdquo;</p>
<p>To help reduce performances, the document advises that &ldquo;the enclave writer
should design an application enclave that keeps as little state information
as possible inside the enclave, so the application can survive a power
transition event smoothly.&rdquo;</p>
<h3 id="425d4b79-de26-457c-a995-f85f18910542">Use of Large Addresses for 32-bit Enclaves</h3>
<p>&ldquo;When an enclave writer develops a 32-bit enclave&rdquo;, &ldquo;the enclave may be
loaded into a large address [&hellip;] or it may receive a pointer from a large
address range&rdquo;, not fitting into the 32-bit integer representation.</p>
<p>Then, &ldquo;the enclave should be designed to cope with these scenarios and fail
smartly.&rdquo;</p>
<p>More generally for any 32-bits applications, &ldquo;all 32-bit enclaves should
expect that they can be loaded above the 2 GB limit or receive a pointer that
references memory above this limit&rdquo;.</p>
<h3 id="0c9e9dfd-5240-4aa2-8a91-f04f7c129fb8">Threading Topics</h3>
<p>This chapter tackles thread binding and the implication regarding the
communication between trusted and untrusted context. There are two thread
binding policies that the developer may choose. I am not aware of thread
mechanism, therefore I do not understand this part.</p>
<p>What I understand though, is that &ldquo;thread synchronization objects, mutexes in
particular, cannot be used safely across root enclave calls regardless the
Thread Binding Policy&rdquo;.</p>
<h3 id="0521c454-0520-4185-86a0-82187571f796">Protection from Side-Channel Attacks</h3>
<p>&ldquo;Intel SGX does not provide explicit protection from side-channel attacks. It
is the enclave developer&rsquo;s responsibility to address side-channel attack
concerns.&rdquo;</p>
<!--more-->
<h2 id="notes-linking-here">Notes linking here</h2>
<ul>
<li><a href="/braindump/posts/intel_enhanced_privacy_id/">Intel® Enhanced Privacy ID</a></li>
<li><a href="/braindump/posts/intel_sgx/#d4742dd2-fd6d-4873-a173-0a68b1d67f9f">Ma compréhension</a></li>
<li><a href="/braindump/posts/sgx_101/">sgx 101</a></li>
</ul>
<h2 id="bibliography">Bibliography</h2>
<h2 id="références">Références</h2>
<style>.csl-left-margin{float: left; padding-right: 0em;}
 .csl-right-inline{margin: 0 0 0 1em;}</style><div class="csl-bib-body">
  <div class="csl-entry"><a id="citeproc_bib_item_1"></a>
    <div class="csl-left-margin">[1]</div><div class="csl-right-inline">Intel® software guard extensions (intel® sgx) developer guide, <a href="https://download.01.org/intel-sgx/sgx-linux/2.12/docs/Intel_SGX_Developer_Guide.pdf">https://download.01.org/intel-sgx/sgx-linux/2.12/docs/Intel_SGX_Developer_Guide.pdf</a>.</div>
  </div>
</div>
<h2 id="permalink"><a href="https://konubinix.eu/braindump/9f59d60a-7abd-4634-b5ab-f971c5170daa?title=sgx_documentation">Permalink</a></h2>
      </div>
	  <aside class="date"><time>Last updated: 09 Apr 2025</time></aside>
	  <aside class="date"><time>Published&nbsp;&nbsp;&nbsp;: 07 Dec 2020</time></aside>
    </div>
  </div>
</div>

<script src="/braindump/js/URI.js" type="text/javascript"></script>

<script src="/braindump/js/page.js" type="text/javascript"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>
